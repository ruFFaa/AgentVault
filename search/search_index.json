{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"AgentVault","text":"<p>AgentVault is an open-source ecosystem designed to facilitate secure and interoperable communication between AI agents (Agent-to-Agent or A2A).</p> <p>This project provides libraries, tools, and specifications to enable seamless interaction in a multi-agent world.</p> <p>\u27a1\ufe0f Public Registry &amp; UI Available!</p> <p>A live instance of the AgentVault Registry API and its associated Web UI is hosted at: <code>https://agentvault-registry-api.onrender.com</code></p> <ul> <li>Public Discovery UI: <code>https://agentvault-registry-api.onrender.com/ui</code></li> <li>Developer Portal UI: <code>https://agentvault-registry-api.onrender.com/ui/developer</code></li> <li>API Base: <code>https://agentvault-registry-api.onrender.com/api/v1</code></li> <li>Note (Cold Start): This is hosted on Render's free tier. If inactive, it may take up to 60 seconds to \"wake up\" on the first request. You can visit the <code>/health</code> endpoint or the UI to wake it up.</li> </ul> <p>\u27a1\ufe0f For detailed documentation, please visit the AgentVault Documentation Hub \u2b05\ufe0f (Note: Documentation is actively being developed)</p>"},{"location":"#components","title":"Components","text":"<p>The AgentVault monorepo contains the following key components:</p> <ul> <li><code>agentvault_library</code>: (Developer Guide) Core Python client library for interacting with A2A agents, managing keys, and handling protocols (A2A, MCP).</li> <li><code>agentvault_cli</code>: (User Guide) Command-line interface for users and developers to manage credentials, discover agents, and run tasks.</li> <li><code>agentvault_registry</code>: (Developer Guide) Backend API server (FastAPI) acting as the central discovery point for registered agents. Also serves a Web UI for public discovery (<code>/ui</code>) and developer management (<code>/ui/developer</code>). (Live instance available above)</li> <li><code>agentvault_server_sdk</code>: (Developer Guide) Python SDK to help developers build A2A-compliant agent servers easily, integrating with frameworks like FastAPI. Includes packaging tools.</li> <li><code>agentvault_testing_utils</code>: (Developer Guide) Shared mocks, fixtures, factories, and helpers for testing AgentVault components.</li> <li><code>examples/</code>: Contains practical examples demonstrating how to use the SDK and library (e.g., basic A2A server, LangChain integration). See the Examples Overview.</li> <li><code>automation_scripts/</code>: (Coming Soon) Scripts to automate common workflows like agent packaging and deployment.</li> <li><code>docs/</code>: Source files for this documentation website (built with MkDocs).</li> </ul>"},{"location":"#installation","title":"Installation","text":"<p>Please refer to the Installation Guide. For development setup, see the Contributing Guide.</p>"},{"location":"#contributing","title":"Contributing","text":"<p>Contributions are welcome! Please see the Contributing Guide for details on setting up the development environment, running tests, and submitting changes.</p>"},{"location":"#license","title":"License","text":"<p>AgentVault is licensed under the Apache License, Version 2.0. See the LICENSE file in the project root for details.</p>"},{"location":"CODE_OF_CONDUCT/","title":"Contributor Covenant Code of Conduct","text":""},{"location":"CODE_OF_CONDUCT/#our-pledge","title":"Our Pledge","text":"<p>We as members, contributors, and leaders pledge to make participation in our community a harassment-free experience for everyone, regardless of age, body size, visible or invisible disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, religion, or sexual identity and orientation.</p> <p>We pledge to act and interact in ways that contribute to an open, welcoming, diverse, inclusive, and healthy community.</p>"},{"location":"CODE_OF_CONDUCT/#our-standards","title":"Our Standards","text":"<p>Examples of behavior that contributes to a positive environment for our community include:</p> <ul> <li>Demonstrating empathy and kindness toward other people</li> <li>Being respectful of differing opinions, viewpoints, and experiences</li> <li>Giving and gracefully accepting constructive feedback</li> <li>Accepting responsibility and apologizing to those affected by our mistakes,   and learning from the experience</li> <li>Focusing on what is best not just for us as individuals, but for the   overall community</li> </ul> <p>Examples of unacceptable behavior include:</p> <ul> <li>The use of sexualized language or imagery, and sexual attention or   advances of any kind</li> <li>Trolling, insulting or derogatory comments, and personal or political attacks</li> <li>Public or private harassment</li> <li>Publishing others' private information, such as a physical or email   address, without their explicit permission</li> <li>Other conduct which could reasonably be considered inappropriate in a   professional setting</li> </ul>"},{"location":"CODE_OF_CONDUCT/#enforcement-responsibilities","title":"Enforcement Responsibilities","text":"<p>Community leaders are responsible for clarifying and enforcing our standards of acceptable behavior and will take appropriate and fair corrective action in response to any behavior that they deem inappropriate, threatening, offensive, or harmful.</p> <p>Community leaders have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, and will communicate reasons for moderation decisions when appropriate.</p>"},{"location":"CODE_OF_CONDUCT/#scope","title":"Scope","text":"<p>This Code of Conduct applies within all community spaces, and also applies when an individual is officially representing the community in public spaces. Examples of representing our community include using an official e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event.</p>"},{"location":"CODE_OF_CONDUCT/#enforcement","title":"Enforcement","text":"<p>Instances of abusive, harassing, or otherwise unacceptable behavior may be reported to the community leaders responsible for enforcement at:</p> <p><code>[CONTACT_EMAIL_PLACEHOLDER]</code></p> <p>[IMPORTANT NOTE]: This email address is a placeholder and MUST be replaced with the actual project contact email before public release.</p> <p>All complaints will be reviewed and investigated promptly and fairly.</p> <p>All community leaders are obligated to respect the privacy and security of the reporter of any incident.</p>"},{"location":"CODE_OF_CONDUCT/#enforcement-guidelines","title":"Enforcement Guidelines","text":"<p>Community leaders will follow these Community Impact Guidelines in determining the consequences for any action they deem in violation of this Code of Conduct:</p>"},{"location":"CODE_OF_CONDUCT/#1-correction","title":"1. Correction","text":"<p>Community Impact: Use of inappropriate language or other behavior deemed unprofessional or unwelcome in the community.</p> <p>Consequence: A private, written warning from community leaders, providing clarity around the nature of the violation and an explanation of why the behavior was inappropriate. A public apology may be requested.</p>"},{"location":"CODE_OF_CONDUCT/#2-warning","title":"2. Warning","text":"<p>Community Impact: A violation through a single incident or series of actions.</p> <p>Consequence: A warning with consequences for continued behavior. No interaction with the people involved, including unsolicited interaction with those enforcing the Code of Conduct, for a specified period of time. This includes avoiding interactions in community spaces as well as external channels like social media. Violating these terms may lead to a temporary or permanent ban.</p>"},{"location":"CODE_OF_CONDUCT/#3-temporary-ban","title":"3. Temporary Ban","text":"<p>Community Impact: A serious violation of community standards, including sustained inappropriate behavior.</p> <p>Consequence: A temporary ban from any sort of interaction or public communication with the community for a specified period of time. No public or private interaction with the people involved, including unsolicited interaction with those enforcing the Code of Conduct, is allowed during this period. Violating these terms may lead to a permanent ban.</p>"},{"location":"CODE_OF_CONDUCT/#4-permanent-ban","title":"4. Permanent Ban","text":"<p>Community Impact: Demonstrating a pattern of violation of community standards, including sustained inappropriate behavior, harassment of an individual, or aggression toward or disparagement of classes of individuals.</p> <p>Consequence: A permanent ban from any sort of public interaction within the community.</p>"},{"location":"CODE_OF_CONDUCT/#attribution","title":"Attribution","text":"<p>This Code of Conduct is adapted from the Contributor Covenant, version 2.1, available at https://www.contributor-covenant.org/version/2/1/code_of_conduct.html.</p> <p>Community Impact Guidelines were inspired by Mozilla's code of conduct enforcement ladder.</p> <p>For answers to common questions about this code of conduct, see the FAQ at https://www.contributor-covenant.org/faq. Translations are available at https://www.contributor-covenant.org/translations.</p>"},{"location":"CONTRIBUTING/","title":"Contributing to AgentVault","text":"<p>First off, thank you for considering contributing to AgentVault! It's people like you that make open source great. Your contributions help build a robust and interoperable ecosystem for AI agents.</p> <p>Please take a moment to review this document in order to make the contribution process easy and effective for everyone involved.</p>"},{"location":"CONTRIBUTING/#getting-started","title":"Getting Started","text":"<ol> <li>Fork the Repository: Start by forking the main AgentVault repository on GitHub.</li> <li>Clone Your Fork: Clone your forked repository to your local machine.     <pre><code>git clone https://github.com/YOUR-USERNAME/AgentVault.git\ncd AgentVault\n</code></pre></li> <li>Install Prerequisites: Ensure you have Git and a compatible Python version (3.10 or 3.11) installed.</li> <li>Install Poetry: If you don't have Poetry installed, follow the instructions on the official Poetry website. Poetry is used for dependency management and packaging across the monorepo.</li> <li>Set up Virtual Environment &amp; Install Dependencies: Navigate to the project root (<code>AgentVault/</code>) and run:     <pre><code>poetry install --with dev\n</code></pre>     This command performs several crucial steps:<ul> <li>Reads the <code>pyproject.toml</code> files within each component package (<code>agentvault_library</code>, <code>agentvault_cli</code>, etc.).</li> <li>Resolves all dependencies across the entire workspace, ensuring compatibility.</li> <li>Creates a single virtual environment (usually <code>.venv/</code> in the project root) for the whole project.</li> <li>Installs all production and development dependencies (like <code>pytest</code>, <code>httpx</code>, <code>mkdocs</code>, <code>ruff</code>) into this shared virtual environment.</li> </ul> </li> <li>Activate Virtual Environment: Before running any commands, tests, or development servers, activate the virtual environment:<ul> <li>Linux/macOS (bash/zsh): <pre><code>source .venv/bin/activate\n</code></pre></li> <li>Windows (PowerShell): <pre><code>.\\.venv\\Scripts\\Activate.ps1\n</code></pre></li> <li>Windows (Command Prompt): <pre><code>.\\.venv\\Scripts\\activate.bat\n</code></pre> Your command prompt should now indicate you are inside the <code>(.venv)</code> environment.</li> </ul> </li> </ol>"},{"location":"CONTRIBUTING/#development-workflow","title":"Development Workflow","text":"<ol> <li>Find/Create an Issue: Look for existing issues or create a new one on GitHub to discuss the bug or feature you want to work on. This helps coordinate efforts.</li> <li>Branching: Create a descriptive feature branch off the <code>main</code> branch:     <pre><code>git checkout main\ngit pull origin main # Ensure your main is up-to-date\ngit checkout -b feat/my-new-feature # Or fix/resolve-issue-123\n</code></pre></li> <li>Coding:<ul> <li>Make your changes within the relevant component directory (e.g., <code>agentvault_library/src/agentvault/</code>, <code>agentvault_cli/src/agentvault_cli/</code>).</li> <li>Follow existing code style and patterns. We aim for clean, readable, and type-hinted Python code.</li> <li>Ensure new functions, classes, and modules have appropriate docstrings.</li> </ul> </li> <li>Testing:<ul> <li>Write Tests: Add new unit or integration tests for your changes within the corresponding component's <code>tests/</code> directory.</li> <li>Run Tests: Navigate to the component's directory (e.g., <code>cd agentvault_library</code>) and run <code>pytest</code>. Ensure all tests pass, including your new ones.</li> <li>Run All Tests (Optional): From the project root, you can run <code>pytest</code> to execute tests for all components (ensure <code>pytest.ini</code> at the root is configured correctly).</li> </ul> </li> <li>Linting &amp; Formatting: (Tooling setup TBD - e.g., Black, Ruff) Run the project's code formatter and linter to ensure consistency.</li> <li>Documentation: If your changes affect user-facing behavior, APIs, or architecture, update the relevant documentation pages in the <code>/docs</code> directory. Build the docs locally (<code>mkdocs serve</code> from the root) to preview your changes.</li> <li>Committing: Write clear, concise commit messages using conventional commit style (e.g., <code>feat(sdk): Add helper for SSE events</code>, <code>fix(cli): Correct handling of --output-artifacts</code>, <code>docs(library): Improve KeyManager examples</code>). Reference the relevant GitHub issue number (e.g., <code>feat(registry): Implement tag filtering (#42)</code>).</li> <li>Pull Request:<ul> <li>Push your feature branch to your fork: <code>git push origin feat/my-new-feature</code></li> <li>Go to the main AgentVault repository on GitHub and open a Pull Request (PR) from your branch to the <code>main</code> branch.</li> <li>Provide a clear title and description for your PR, explaining the changes and linking to the relevant issue(s).</li> <li>Ensure all automated checks (CI workflows like tests and dependency audits) pass on your PR. Address any failures.</li> <li>Engage in the code review process if feedback is provided.</li> </ul> </li> </ol>"},{"location":"CONTRIBUTING/#code-style","title":"Code Style","text":"<p>(Placeholder: This section will be updated once specific tools like Black/Ruff are enforced via pre-commit hooks or CI.)</p> <p>Generally, adhere to PEP 8 guidelines and follow the style of the existing codebase. Use type hints extensively.</p>"},{"location":"CONTRIBUTING/#testing","title":"Testing","text":"<ul> <li>Unit Tests: Focus on testing individual functions and classes in isolation. Place these in the relevant component's <code>tests/</code> directory (e.g., <code>agentvault_library/tests/library/</code>).</li> <li>Integration Tests: Test the interaction between different parts of a component or between components (e.g., CLI using the Library against a mock server). Place these in appropriate subdirectories within <code>tests/</code>.</li> <li>Coverage: Aim for high test coverage for new code. (Coverage reporting setup TBD).</li> <li>Running Tests: Activate the virtual environment and run <code>pytest</code> from the component directory or the project root.</li> </ul>"},{"location":"CONTRIBUTING/#dependency-security","title":"Dependency Security","text":"<p>This project uses <code>pip-audit</code> via a GitHub Actions workflow (<code>.github/workflows/dependency_audit.yml</code>) to automatically check for known vulnerabilities in project dependencies based on the <code>poetry.lock</code> files.</p> <ul> <li>Workflow: Triggers on pushes/PRs to <code>main</code>. Audits each component separately.</li> <li>Reviewing Audits: Check the \"Actions\" tab on GitHub for the \"Security Dependency Audit\" results. Failures indicate known vulnerabilities.</li> <li>Updating Dependencies: Use <code>poetry update &lt;package_name&gt;</code> within a component directory to update specific dependencies, or <code>poetry update</code> to update all allowed by <code>pyproject.toml</code>. Always re-run <code>poetry lock</code> and commit the updated lock file. Re-run tests thoroughly after updates.</li> </ul>"},{"location":"CONTRIBUTING/#reporting-issues-security-vulnerabilities","title":"Reporting Issues &amp; Security Vulnerabilities","text":"<ul> <li>Bugs &amp; Feature Requests: Please check existing GitHub Issues first. If your issue isn't there, open a new one with detailed information.</li> <li>Security Vulnerabilities: DO NOT report security issues publicly. Please follow the instructions in our Security Policy (security_policy.md).</li> </ul>"},{"location":"CONTRIBUTING/#code-of-conduct","title":"Code of Conduct","text":"<p>This project adheres to the Contributor Covenant Code of Conduct. By participating, you are expected to uphold this code.</p> <p>Thank you for contributing to AgentVault!</p>"},{"location":"REGISTRY_POLICY/","title":"AgentVault Registry Policy","text":""},{"location":"REGISTRY_POLICY/#1-purpose-of-the-registry","title":"1. Purpose of the Registry","text":"<p>The AgentVault Registry serves as a public discovery hub for AI agents compatible with the AgentVault ecosystem and the Agent-to-Agent (A2A) protocol. Its primary purpose is to store and serve standardized Agent Card metadata submitted by agent developers.</p> <p>The Registry DOES NOT:</p> <ul> <li>Execute or host third-party agents.</li> <li>Handle, store, or process end-user API keys (like OpenAI, Anthropic keys).</li> <li>Proxy or monitor A2A communication between clients and agents.</li> <li>Guarantee the functionality, security, safety, or ethical behavior of the agents listed.</li> </ul>"},{"location":"REGISTRY_POLICY/#2-agent-card-submissions","title":"2. Agent Card Submissions","text":"<ul> <li>Eligibility: Only authenticated developers who have registered with the AgentVault Registry service (process TBD, currently via API key assigned by maintainers) can submit, update, or deactivate Agent Cards.</li> <li>Responsibility: Developers are solely responsible for the accuracy and completeness of the information provided in their submitted Agent Cards, including endpoint URLs, authentication details, descriptions, and links to their own policies.</li> </ul>"},{"location":"REGISTRY_POLICY/#3-vetting-process","title":"3. Vetting Process","text":"<ul> <li>Automated Validation: Submitted Agent Cards undergo automated validation against the official A2A Agent Card schema (<code>agentvault.models.AgentCard</code>) to ensure structural correctness. Basic checks may also be performed to verify the format of the specified A2A endpoint URL.</li> <li>No Behavioral Vetting: The AgentVault Registry does not perform manual reviews or vetting of the underlying agent's functionality, security practices, data handling procedures, or ethical alignment. Listing in the registry does not imply endorsement or certification by the AgentVault project.</li> </ul>"},{"location":"REGISTRY_POLICY/#4-content-guidelines-summary","title":"4. Content Guidelines (Summary)","text":"<p>Agent Card metadata submitted to the registry must not:</p> <ul> <li>Promote or facilitate illegal activities.</li> <li>Contain hateful, discriminatory, or harassing content.</li> <li>Be intentionally deceptive or misleading about the agent's capabilities or purpose.</li> <li>Infringe on the intellectual property rights of others.</li> <li>Link to malicious websites or resources.</li> </ul> <p>(A more detailed content policy may be developed later).</p>"},{"location":"REGISTRY_POLICY/#5-reporting-problematic-agents","title":"5. Reporting Problematic Agents","text":"<p>Users who encounter Agent Cards that appear to violate the Content Guidelines, are misleading, link to non-functional or malicious endpoints, or represent agents engaging in harmful activities are encouraged to report them.</p> <ul> <li> <p>How to Report: Please send a detailed report including the Agent Card ID (the UUID) and a description of the issue to:</p> <p><code>[CONTACT_EMAIL_PLACEHOLDER]</code></p> <p>[IMPORTANT NOTE]: This email address is a placeholder and MUST be replaced with the actual project contact email before public release.</p> </li> <li> <p>Review Process: Reports will be reviewed by the AgentVault maintainers based on this policy.</p> </li> </ul>"},{"location":"REGISTRY_POLICY/#6-enforcement","title":"6. Enforcement","text":"<p>AgentVault maintainers reserve the right, at their sole discretion, to:</p> <ul> <li>Deactivate (soft delete, making <code>is_active=False</code>) any Agent Card found to violate the Registry Policy or Content Guidelines.</li> <li>Temporarily or permanently suspend a developer's ability to submit or manage Agent Cards in response to repeated or severe violations.</li> <li>Remove Agent Cards linking to endpoints that are consistently unavailable or return errors indicative of non-compliance with the A2A protocol.</li> </ul>"},{"location":"REGISTRY_POLICY/#7-disclaimer","title":"7. Disclaimer","text":"<p>The AgentVault Registry is provided \"as is\". Users interact with third-party agents discovered through this registry at their own risk. The AgentVault project makes no warranties regarding the agents listed and is not liable for any damages or issues arising from interactions with those agents. Please review the agent provider's own Terms of Service and Privacy Policy before use.</p>"},{"location":"ROADMAP/","title":"AgentVault Project Roadmap","text":"<p>This document outlines the planned development phases and features for the AgentVault ecosystem. Our goal is to create a secure, interoperable, and easy-to-use platform for AI agent communication based on open standards like A2A and MCP concepts.</p> <p>Disclaimer: This roadmap represents our current plans and priorities. It is subject to change based on development progress, community feedback, and the evolution of underlying standards.</p>"},{"location":"ROADMAP/#current-status-april-2025","title":"Current Status (April 2025)","text":"<p>The AgentVault project has established a functional baseline across its core components:</p> <ul> <li><code>agentvault</code> Library: Core client implemented for A2A JSON-RPC/SSE interactions, API Key/None/OAuth2 (Client Creds) auth, secure local KeyManager (env, file, keyring), Agent Card parsing/validation, basic MCP utilities. Published on PyPI.</li> <li><code>agentvault_registry</code> API: FastAPI backend operational, supporting Agent Card submission/management (developer key auth), validation, list/search/get (including basic TEE/tag filtering), developer verification status. Uses PostgreSQL/Alembic. Basic rate limiting and CORS in place. Basic Web UI for discovery and developer portal implemented. (Note: Developer registration is currently manual/admin-driven).</li> <li><code>agentvault_cli</code>: Functional CLI for local key config (<code>config</code>), registry discovery (<code>discover</code>), and task execution (<code>run</code>) using the library. Includes <code>rich</code> output formatting and artifact saving.</li> <li><code>agentvault_server_sdk</code>: Foundational SDK available with <code>BaseA2AAgent</code>, FastAPI integration (<code>create_a2a_router</code>, <code>@a2a_method</code>), <code>InMemoryTaskStore</code> with listener/notification support, and packaging tool (<code>agentvault-sdk package</code>). Published on PyPI.</li> <li><code>agentvault_testing_utils</code>: Shared utilities including <code>MockAgentVaultClient</code>, <code>mock_a2a_server</code> fixture, <code>create_test_agent_card</code> factory, <code>EchoAgent</code>, and assertion helpers.</li> <li>Documentation: Foundational documentation structure created with MkDocs, core concepts/architecture/security outlined, component guides drafted, A2A profile documented, examples added. Deployed via GitHub Pages.</li> <li>CI/CD: Workflows for dependency audit and documentation deployment are functional.</li> </ul>"},{"location":"ROADMAP/#next-steps-phase-25-ecosystem-enablement-refinement","title":"Next Steps: Phase 2.5 - Ecosystem Enablement &amp; Refinement","text":"<p>Objective: Solidify the existing components, improve developer/user experience through better documentation and examples, and prepare for broader adoption.</p> <p>Key Tasks:</p> <ol> <li>Documentation Overhaul (Largely Complete - Minor Polish Remaining):<ul> <li>Enhance Component Guides (Done).</li> <li>Improve Core Concepts (Done).</li> <li>Finalize Policies (Placeholders updated).</li> <li>Installation Guide (Enhanced).</li> <li>Examples Overview (Updated).</li> <li>Vision Document (Added).</li> <li>Use Cases Document (Added).</li> </ul> </li> <li>Example Implementations (Complete):<ul> <li>Basic A2A Server (Done).</li> <li>LangChain Integration (Done).</li> <li>OAuth Agent Example (Done).</li> <li>Stateful Agent Example (Done).</li> <li>Direct Library Usage Example (Done).</li> </ul> </li> <li>Registry UI/UX Improvements:<ul> <li>TODO: Enhance the developer portal UI (<code>/ui/developer</code>) for easier card management (editing, viewing status).</li> <li>TODO: Improve filtering/search capabilities on the public UI (<code>/ui</code>).</li> <li>TODO: Display developer verification status clearly.</li> </ul> </li> <li>SDK &amp; Testing Refinements:<ul> <li>TODO: Improve Server SDK state management abstractions (consider adding basic persistent store examples or interfaces).</li> <li>TODO: Expand <code>agentvault-testing-utils</code> with more assertion helpers or complex mocks as needed.</li> <li>TODO: Increase test coverage across all components.</li> </ul> </li> <li>TEE Feature Polish:<ul> <li>TODO: Test and verify TEE filtering in the registry API and UI works reliably.</li> <li>TODO: Ensure TEE support limitations (declarative only) are clearly documented (<code>tee_profile.md</code>).</li> </ul> </li> </ol>"},{"location":"ROADMAP/#future-considerations-beyond-phase-25-ideas","title":"Future Considerations (Beyond Phase 2.5 / Ideas)","text":"<ul> <li>Phase 2.6: Automation &amp; Robustness:<ul> <li>Implement the <code>automation_scripts/</code> (<code>av_create_package_agent</code>, <code>av_deploy_register_agent</code>, <code>av_find_run_task</code>).</li> <li>Address scalability concerns (e.g., registry developer key lookup).</li> <li>Enhance Server SDK state management (persistent stores like DB/Redis).</li> <li>Improve error handling depth across all components.</li> </ul> </li> <li>Phase 3: Advanced Features &amp; Ecosystem Growth:<ul> <li>Developer Self-Registration: Implement a secure self-service workflow for developers to register and obtain API keys via the Registry API/UI (including email verification).</li> <li>Multimodality (WebRTC): Integrate <code>aiortc</code> for optional real-time audio/video streaming support within the A2A protocol.</li> <li>Deeper MCP Integration: Align with finalized MCP specifications, provide SDK helpers for context manipulation.</li> <li>TEE Attestation Verification: Implement client-side verification of TEE attestations based on <code>attestationEndpoint</code> in Agent Cards.</li> <li>Registry Enhancements: Community reviews/ratings, usage analytics (opt-in), more advanced search/filtering, improved developer portal features (key rotation, etc.).</li> <li>Other Language SDKs/Libraries: Explore SDKs for Node.js, Go, etc.</li> <li>Security Audits: Formal third-party security reviews.</li> </ul> </li> </ul>"},{"location":"ROADMAP/#contributing","title":"Contributing","text":"<p>We welcome community contributions! Please see our CONTRIBUTING.md for guidelines on reporting issues, suggesting features, and submitting pull requests. You can also join discussions on our GitHub repository.</p>"},{"location":"TERMS_OF_SERVICE/","title":"AgentVault Registry API - Terms of Service","text":"<p>Last Updated: [April 12, 2025]</p> <p>PLEASE READ THESE TERMS OF SERVICE CAREFULLY. By accessing or using the AgentVault Registry API (the \"Service\"), provided by the AgentVault Project Maintainers (\"we\", \"us\", \"our\"), you (\"Developer\", \"you\") agree to be bound by these Terms of Service (\"Terms\"). If you do not agree to these Terms, do not use the Service.</p> <p>1. The Service</p> <p>The AgentVault Registry API is a service designed to facilitate the discovery of AI agents compatible with the AgentVault ecosystem. It allows registered developers to submit, manage, and publish metadata (\"Agent Cards\") describing their agents. The Service provides public endpoints for listing and retrieving these Agent Cards.</p> <p>The Service DOES NOT: *   Host or execute third-party AI agents. *   Store, handle, or process end-user API keys (e.g., OpenAI keys) used by agents. *   Monitor or proxy communication between users and agents. *   Endorse, certify, or guarantee the functionality, security, or behavior of any agent listed in the registry.</p> <p>2. Developer Accounts &amp; API Keys</p> <ul> <li>Access to submit or manage Agent Cards requires authentication using an API key provided by us.</li> <li>You are responsible for maintaining the confidentiality and security of your assigned API key. Do not share your key.</li> <li>You are responsible for all activities that occur under your API key. Notify us immediately of any unauthorized use.</li> <li>We reserve the right to revoke or suspend API keys if we suspect misuse or violation of these Terms.</li> </ul> <p>3. Agent Card Submissions &amp; Content</p> <ul> <li>By submitting an Agent Card to the Service, you represent and warrant that:<ul> <li>You own or have the necessary rights to the content included in the Agent Card.</li> <li>The information provided in the Agent Card is accurate, complete, and not misleading.</li> <li>The Agent Card content and the agent it describes comply with the AgentVault Registry Policy and all applicable laws and regulations.</li> <li>The Agent Card content does not infringe upon the intellectual property rights, privacy rights, or other rights of any third party.</li> </ul> </li> <li>You grant the AgentVault Project Maintainers a worldwide, non-exclusive, royalty-free license to host, display, reproduce, and distribute the submitted Agent Card metadata solely for the purpose of operating and promoting the AgentVault Registry and ecosystem.</li> <li>You are solely responsible for the agent service described in your Agent Card, including its operation, security, data handling, and compliance with its own terms and privacy policy.</li> </ul> <p>4. Prohibited Use</p> <p>You agree not to use the Service to:</p> <ul> <li>Submit Agent Cards that violate the AgentVault Registry Policy.</li> <li>Engage in any activity that is illegal, fraudulent, or harmful.</li> <li>Attempt to gain unauthorized access to the Service, other accounts, or related systems.</li> <li>Disrupt, interfere with, or place an unreasonable load on the Service or its infrastructure (e.g., excessive scraping, denial-of-service attacks).</li> <li>Misrepresent your identity or affiliation.</li> </ul> <p>5. Disclaimers</p> <ul> <li>THE SERVICE IS PROVIDED \"AS IS\" AND \"AS AVAILABLE\" WITHOUT WARRANTIES OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE, AND NON-INFRINGEMENT.</li> <li>WE DO NOT WARRANT THAT THE SERVICE WILL BE UNINTERRUPTED, ERROR-FREE, OR SECURE.</li> <li>WE EXPLICITLY DISCLAIM ANY AND ALL LIABILITY AND RESPONSIBILITY FOR ANY THIRD-PARTY AGENTS DISCOVERED THROUGH THE SERVICE. YOUR INTERACTION WITH ANY AGENT LISTED IN THE REGISTRY IS SOLELY AT YOUR OWN RISK. WE DO NOT VET, ENDORSE, OR GUARANTEE ANY AGENT'S PERFORMANCE, SECURITY, DATA PRACTICES, OR COMPLIANCE. YOU ARE RESPONSIBLE FOR REVIEWING THE TERMS AND PRIVACY POLICY OF ANY AGENT BEFORE INTERACTING WITH IT.</li> </ul> <p>6. Intellectual Property</p> <ul> <li>The AgentVault name, logos, and the Service software are the property of the AgentVault Project Maintainers or its licensors and are protected by intellectual property laws.</li> <li>You retain ownership of the content within your submitted Agent Cards, subject to the license granted in Section 3.</li> </ul> <p>7. Termination</p> <ul> <li>We reserve the right to suspend or terminate your access to the Service (including revoking API keys and deactivating Agent Cards) at any time, with or without cause or notice, for conduct that we believe violates these Terms or is otherwise harmful to the Service or community.</li> <li>You may stop using the Service at any time.</li> </ul> <p>8. Limitation of Liability</p> <p>TO THE FULLEST EXTENT PERMITTED BY APPLICABLE LAW, IN NO EVENT SHALL THE AGENTVAULT PROJECT MAINTAINERS, THEIR AFFILIATES, OR THEIR LICENSORS BE LIABLE FOR ANY INDIRECT, INCIDENTAL, SPECIAL, CONSEQUENTIAL, OR PUNITIVE DAMAGES, OR ANY LOSS OF PROFITS OR REVENUES, WHETHER INCURRED DIRECTLY OR INDIRECTLY, OR ANY LOSS OF DATA, USE, GOODWILL, OR OTHER INTANGIBLE LOSSES, RESULTING FROM (a) YOUR ACCESS TO OR USE OF OR INABILITY TO ACCESS OR USE THE SERVICE; (b) ANY CONDUCT OR CONTENT OF ANY THIRD PARTY ON THE SERVICE, INCLUDING THIRD-PARTY AGENTS DISCOVERED VIA THE SERVICE; OR (c) UNAUTHORIZED ACCESS, USE, OR ALTERATION OF YOUR TRANSMISSIONS OR CONTENT.</p> <p>9. Governing Law</p> <p>These Terms shall be governed by and construed in accordance with the laws of [Bavaria, Germany], without regard to its conflict of law principles.</p> <p>10. Changes to Terms</p> <p>We reserve the right to modify these Terms at any time. If we make changes, we will provide notice, such as by updating the \"Last Updated\" date at the top of these Terms. Your continued use of the Service after any modification constitutes your acceptance of the revised Terms.</p> <p>11. Contact Information</p> <p>For questions about these Terms of Service, please contact:</p> <p><code>[CONTACT_EMAIL_PLACEHOLDER]</code></p> <p>[IMPORTANT NOTE]: This email address is a placeholder and MUST be replaced with the actual project contact email before public release.</p>"},{"location":"a2a_profile_v0.2/","title":"AgentVault A2A Profile v0.2","text":"<p>This document specifies the Agent-to-Agent (A2A) communication profile implemented by AgentVault components (as of v0.2.x of the libraries/SDK). It defines how clients interact with A2A-compliant agent servers, aligning with concepts from emerging A2A standards like Google's A2A protocol.</p>"},{"location":"a2a_profile_v0.2/#overview","title":"Overview","text":"<ul> <li>Protocol: JSON-RPC 2.0 Specification.</li> <li>Transport: HTTP/1.1 or HTTP/2. HTTPS is REQUIRED for all communication except potentially during local development targeting <code>localhost</code>.</li> <li>Request Method: <code>POST</code> for all JSON-RPC requests.</li> <li>Streaming: Server-Sent Events (SSE) via the <code>tasks/sendSubscribe</code> method for real-time updates.</li> <li>Data Format: JSON (UTF-8 encoding).</li> <li>Authentication: Defined via <code>authSchemes</code> in the Agent Card. Supported schemes include <code>none</code>, <code>apiKey</code>, and <code>oauth2</code> (Client Credentials Grant). See Authentication section below.</li> <li>Models: Data structures (AgentCard, Task, Message, etc.) are defined using Pydantic in the <code>agentvault.models</code> module of the core library.</li> </ul>"},{"location":"a2a_profile_v0.2/#transport-details","title":"Transport Details","text":"<p>All JSON-RPC requests MUST be sent using the HTTP <code>POST</code> method to the agent's designated A2A endpoint URL (found in the <code>url</code> field of its Agent Card).</p> <ul> <li>Request Headers:<ul> <li><code>Content-Type: application/json</code> is REQUIRED.</li> <li><code>Accept: application/json</code> is RECOMMENDED.</li> <li>Authentication headers (e.g., <code>X-Api-Key</code> or <code>Authorization: Bearer &lt;token&gt;</code>) MUST be included if required by the agent's <code>authSchemes</code>.</li> </ul> </li> <li>Request Body: Contains the standard JSON-RPC 2.0 request object.</li> <li>Response Body (Non-Streaming): Contains the standard JSON-RPC 2.0 response object (either <code>result</code> or <code>error</code>). The HTTP status code SHOULD be <code>200 OK</code> even for JSON-RPC errors, as per JSON-RPC spec recommendations.</li> <li>Response Body (Streaming via <code>tasks/sendSubscribe</code>): The server responds with HTTP <code>200 OK</code> and <code>Content-Type: text/event-stream</code>. The body then contains a stream of Server-Sent Events (see SSE section).</li> </ul>"},{"location":"a2a_profile_v0.2/#authentication","title":"Authentication","text":"<p>Agents declare their supported authentication methods in the <code>authSchemes</code> list within their Agent Card. The <code>agentvault</code> client library (<code>AgentVaultClient</code> using <code>KeyManager</code>) handles these schemes automatically:</p> <ul> <li><code>none</code>: No authentication headers are sent. Suitable only for public, non-sensitive agents.</li> <li><code>apiKey</code>:<ul> <li>Client retrieves the API key associated with the <code>service_identifier</code> (from the Agent Card or user override) using <code>KeyManager</code>.</li> <li>Client sends the key in the <code>X-Api-Key</code> HTTP header.</li> <li>Server MUST validate the received key against its secure storage.</li> </ul> </li> <li><code>oauth2</code> (Client Credentials Grant Flow):<ul> <li>Requires the <code>AgentAuthentication</code> object in the card to include <code>tokenUrl</code>. <code>scopes</code> are optional.</li> <li>Client retrieves its own Client ID and Secret associated with the <code>service_identifier</code> using <code>KeyManager</code>.</li> <li>Client POSTs <code>grant_type=client_credentials</code>, <code>client_id</code>, <code>client_secret</code> (and optionally <code>scope</code>) to the agent's <code>tokenUrl</code>.</li> <li>Agent's token endpoint validates credentials and returns a JSON response with <code>access_token</code> (required), <code>token_type</code> (must be \"Bearer\", case-insensitive check), and optionally <code>expires_in</code>.</li> <li>Client sends the received <code>access_token</code> in the <code>Authorization: Bearer &lt;token&gt;</code> header for subsequent A2A requests to the agent's main <code>url</code>.</li> <li>The <code>AgentVaultClient</code> automatically handles token fetching and caching (respecting <code>expires_in</code> if provided).</li> <li>Server's main A2A endpoint MUST validate the Bearer token (signature, expiry, audience, scopes if applicable).</li> </ul> </li> <li><code>bearer</code>:<ul> <li>Client assumes the user/application has already obtained a valid Bearer token through other means.</li> <li>Client sends the token in the <code>Authorization: Bearer &lt;token&gt;</code> header.</li> <li>The <code>agentvault</code> library currently requires explicit configuration or extension to handle this scheme, as it doesn't manage the token lifecycle.</li> <li>Server MUST validate the received Bearer token.</li> </ul> </li> </ul> <p>Refer to the main Security Considerations document for more details.</p>"},{"location":"a2a_profile_v0.2/#json-rpc-20-structure","title":"JSON-RPC 2.0 Structure","text":"<p>All requests and responses adhere to the JSON-RPC 2.0 specification.</p> <p>Request Object:</p> <pre><code>{\n  \"jsonrpc\": \"2.0\",\n  \"method\": \"method_name\",\n  \"params\": &lt;parameters_object_or_array&gt;,\n  \"id\": &lt;request_id_string_or_number_or_null&gt;\n}\n</code></pre> <ul> <li><code>jsonrpc</code>: MUST be exactly \"2.0\".</li> <li><code>method</code>: A string containing the name of the method (e.g., \"tasks/send\").</li> <li><code>params</code>: An optional structured value (object or array). AgentVault methods use parameter objects (dictionaries).</li> <li><code>id</code>: An identifier established by the Client. If included, the response MUST include the same value. If omitted (notification), the server MUST NOT reply. AgentVault methods generally expect an ID.</li> </ul> <p>Response Object (Success):</p> <pre><code>{\n  \"jsonrpc\": \"2.0\",\n  \"result\": &lt;result_value&gt;,\n  \"id\": &lt;matching_request_id&gt;\n}\n</code></pre> <ul> <li><code>result</code>: The value returned by the method invocation. Its structure depends on the method called (see method definitions below).</li> <li><code>id</code>: Must match the <code>id</code> from the Request Object.</li> </ul> <p>Response Object (Error):</p> <pre><code>{\n  \"jsonrpc\": \"2.0\",\n  \"error\": {\n    \"code\": &lt;integer&gt;,\n    \"message\": &lt;string&gt;,\n    \"data\": &lt;optional_any&gt;\n  },\n  \"id\": &lt;matching_request_id_or_null&gt;\n}\n</code></pre> <ul> <li><code>error</code>: An object describing the error.<ul> <li><code>code</code>: A Number indicating the error type. See Error Codes.</li> <li><code>message</code>: A String providing a short description of the error.</li> <li><code>data</code>: Optional. A Primitive or Structured value containing additional information.</li> </ul> </li> <li><code>id</code>: Must match the <code>id</code> from the Request Object. If the error occurred before the ID could be determined (e.g., Parse Error), it SHOULD be <code>null</code>.</li> </ul>"},{"location":"a2a_profile_v0.2/#standard-a2a-methods","title":"Standard A2A Methods","text":"<p>These methods form the core of the AgentVault A2A interaction model, implemented by the <code>agentvault</code> client library and expected by servers built with the <code>agentvault-server-sdk</code>.</p>"},{"location":"a2a_profile_v0.2/#taskssend","title":"<code>tasks/send</code>","text":"<p>Initiates a new task or sends a subsequent message to an existing task.</p> <ul> <li>Params: <code>TaskSendParams</code> object (<code>agentvault.models.TaskSendParams</code>)<ul> <li><code>id</code> (Optional[str]): Task ID if continuing an existing task. Omit or null if initiating a new task.</li> <li><code>message</code> (Message): The message object (<code>agentvault.models.Message</code>) to send.</li> <li>(Optional) <code>webhookUrl</code> (Optional[str]): URL for agent push notifications (if agent supports <code>supportsPushNotifications</code>). Client is responsible for handling POST requests to this URL from the agent. (Note: Push notification handling is not fully implemented in client/SDK v0.2).</li> </ul> </li> <li>Result: <code>TaskSendResult</code> object (<code>agentvault.models.TaskSendResult</code>)<ul> <li><code>id</code> (str): The ID of the task (newly created or existing).</li> </ul> </li> <li>Example Request (Initiate): <pre><code>{\n  \"jsonrpc\": \"2.0\",\n  \"method\": \"tasks/send\",\n  \"params\": {\n    \"message\": {\n      \"role\": \"user\",\n      \"parts\": [{\"type\": \"text\", \"content\": \"What is the weather in London?\"}],\n      \"metadata\": {\n        \"mcp_context\": { \"user_pref\": \"celsius\" }\n      }\n    }\n    {# Example including optional webhook: #}\n    {# \"webhookUrl\": \"https://my-client.example.com/webhook/task-updates\" #}\n  },\n  \"id\": \"req-1\"\n}\n</code></pre></li> <li>Example Response (Initiate): <pre><code>{\n  \"jsonrpc\": \"2.0\",\n  \"result\": {\n    \"id\": \"task-abc-123\"\n  },\n  \"id\": \"req-1\"\n}\n</code></pre></li> <li>Example Request (Continue): <pre><code>{\n  \"jsonrpc\": \"2.0\",\n  \"method\": \"tasks/send\",\n  \"params\": {\n    \"id\": \"task-abc-123\",\n    \"message\": {\n      \"role\": \"user\",\n      \"parts\": [{\"type\": \"text\", \"content\": \"What about tomorrow?\"}]\n    }\n  },\n  \"id\": \"req-2\"\n}\n</code></pre></li> <li>Example Response (Continue): <pre><code>{\n  \"jsonrpc\": \"2.0\",\n  \"result\": {\n    \"id\": \"task-abc-123\"\n  },\n  \"id\": \"req-2\"\n}\n</code></pre></li> </ul>"},{"location":"a2a_profile_v0.2/#tasksget","title":"<code>tasks/get</code>","text":"<p>Retrieve the current status and details of a specific task.</p> <ul> <li>Params: <code>TaskGetParams</code> object (<code>agentvault.models.TaskGetParams</code>)<ul> <li><code>id</code> (str): The ID of the task to retrieve.</li> </ul> </li> <li>Result: <code>Task</code> object (<code>agentvault.models.Task</code>) representing the full task state.</li> <li>Example Request: <pre><code>{\n  \"jsonrpc\": \"2.0\",\n  \"method\": \"tasks/get\",\n  \"params\": {\n    \"id\": \"task-abc-123\"\n  },\n  \"id\": \"req-3\"\n}\n</code></pre></li> <li>Example Response: <pre><code>{\n  \"jsonrpc\": \"2.0\",\n  \"result\": {\n    \"id\": \"task-abc-123\",\n    \"state\": \"WORKING\",\n    \"createdAt\": \"2024-04-15T10:00:00Z\",\n    \"updatedAt\": \"2024-04-15T10:05:30Z\",\n    \"messages\": [\n      {\"role\": \"user\", \"parts\": [{\"type\": \"text\", \"content\": \"What is the weather in London?\"}], \"metadata\": null},\n      {\"role\": \"assistant\", \"parts\": [{\"type\": \"text\", \"content\": \"Fetching weather...\"}], \"metadata\": null}\n    ],\n    \"artifacts\": [\n      {\"id\": \"artifact-1\", \"type\": \"log\", \"content\": \"API call made\", \"url\": null, \"mediaType\": \"text/plain\", \"metadata\": null}\n    ],\n    \"metadata\": null\n  },\n  \"id\": \"req-3\"\n}\n</code></pre></li> </ul>"},{"location":"a2a_profile_v0.2/#taskscancel","title":"<code>tasks/cancel</code>","text":"<p>Request the cancellation of an ongoing task.</p> <ul> <li>Params: <code>TaskCancelParams</code> object (<code>agentvault.models.TaskCancelParams</code>)<ul> <li><code>id</code> (str): The ID of the task to cancel.</li> </ul> </li> <li>Result: <code>TaskCancelResult</code> object (<code>agentvault.models.TaskCancelResult</code>)<ul> <li><code>success</code> (bool): Indicates if the cancellation request was accepted by the agent (doesn't guarantee immediate cancellation).</li> <li><code>message</code> (Optional[str]): Optional message from the agent regarding the cancellation request.</li> </ul> </li> <li>Example Request: <pre><code>{\n  \"jsonrpc\": \"2.0\",\n  \"method\": \"tasks/cancel\",\n  \"params\": {\n    \"id\": \"task-abc-123\"\n  },\n  \"id\": \"req-4\"\n}\n</code></pre></li> <li>Example Response: <pre><code>{\n  \"jsonrpc\": \"2.0\",\n  \"result\": {\n    \"success\": true,\n    \"message\": \"Cancellation request received.\"\n  },\n  \"id\": \"req-4\"\n}\n</code></pre></li> </ul>"},{"location":"a2a_profile_v0.2/#taskssendsubscribe","title":"<code>tasks/sendSubscribe</code>","text":"<p>Initiates a subscription to real-time updates for a task via Server-Sent Events (SSE).</p> <ul> <li>Params: Object containing the task ID.<ul> <li><code>id</code> (str): The ID of the task to subscribe to.</li> </ul> </li> <li>Response: HTTP <code>200 OK</code> with <code>Content-Type: text/event-stream</code>. The HTTP response body contains the SSE stream. No JSON-RPC <code>result</code> field is sent in the initial HTTP response body.</li> <li>Example Request: <pre><code>{\n  \"jsonrpc\": \"2.0\",\n  \"method\": \"tasks/sendSubscribe\",\n  \"params\": {\n    \"id\": \"task-abc-123\"\n  },\n  \"id\": \"req-5\"\n}\n</code></pre></li> <li>Example Response (HTTP Headers &amp; Body Start): <pre><code>HTTP/1.1 200 OK\nContent-Type: text/event-stream\nCache-Control: no-cache\nConnection: keep-alive\n\nevent: task_status\ndata: {\"taskId\": \"task-abc-123\", \"state\": \"WORKING\", \"timestamp\": \"2024-04-15T10:05:00Z\", \"message\": null}\n\nevent: task_message\ndata: {\"taskId\": \"task-abc-123\", \"message\": {\"role\": \"assistant\", \"parts\": [{\"type\": \"text\", \"content\": \"Thinking...\"}], \"metadata\": null}, \"timestamp\": \"2024-04-15T10:05:05Z\"}\n\n... (more events) ...\n</code></pre></li> </ul>"},{"location":"a2a_profile_v0.2/#task-states-taskstate-enum","title":"Task States (<code>TaskState</code> Enum)","text":"<p>The defined states for an A2A task lifecycle (<code>agentvault.models.TaskState</code>):</p> <ul> <li><code>SUBMITTED</code>: Task received, awaiting execution.</li> <li><code>WORKING</code>: Task actively being processed.</li> <li><code>INPUT_REQUIRED</code>: Task paused, awaiting further client input (advanced use case).</li> <li><code>COMPLETED</code>: Task finished successfully. (Terminal)</li> <li><code>FAILED</code>: Task terminated due to an error. (Terminal)</li> <li><code>CANCELED</code>: Task canceled by request. (Terminal)</li> </ul>"},{"location":"a2a_profile_v0.2/#server-sent-events-sse","title":"Server-Sent Events (SSE)","text":"<p>Used for the <code>tasks/sendSubscribe</code> stream.</p> <ul> <li>Format: Standard SSE. Each event consists of <code>event:</code> and <code>data:</code> lines, terminated by <code>\\n\\n</code>. The <code>data:</code> field contains a single line JSON string.     <pre><code>event: &lt;event_type&gt;\ndata: &lt;json_payload_string&gt;\n\nevent: &lt;another_event_type&gt;\ndata: &lt;another_json_payload_string&gt;\n</code></pre></li> <li>Event Types (<code>event:</code> field):<ul> <li><code>task_status</code>: Task state change. <code>data</code> is JSON of <code>TaskStatusUpdateEvent</code>.</li> <li><code>task_message</code>: New message added. <code>data</code> is JSON of <code>TaskMessageEvent</code>.</li> <li><code>task_artifact</code>: Artifact created/updated. <code>data</code> is JSON of <code>TaskArtifactUpdateEvent</code>.</li> <li><code>error</code>: Server-side error during streaming. <code>data</code> is a JSON object like <code>{\"error\": \"code\", \"message\": \"desc\"}</code>.</li> </ul> </li> <li>Data Payload (<code>data:</code> field): A JSON string representing the corresponding event model (<code>agentvault.models.TaskStatusUpdateEvent</code>, <code>TaskMessageEvent</code>, <code>TaskArtifactUpdateEvent</code>). The client library validates these payloads against the Pydantic models.</li> </ul> <p>Example SSE Stream:</p> <pre><code>event: task_status\ndata: {\"taskId\": \"task-abc-123\", \"state\": \"WORKING\", \"timestamp\": \"2024-04-15T10:05:00Z\", \"message\": null}\n\nevent: task_message\ndata: {\"taskId\": \"task-abc-123\", \"message\": {\"role\": \"assistant\", \"parts\": [{\"type\": \"text\", \"content\": \"Thinking...\"}], \"metadata\": null}, \"timestamp\": \"2024-04-15T10:05:05Z\"}\n\nevent: task_artifact\ndata: {\"taskId\": \"task-abc-123\", \"artifact\": {\"id\": \"log-1\", \"type\": \"debug_log\", \"content\": \"Processing step 1\", \"url\": null, \"mediaType\": \"text/plain\", \"metadata\": null}, \"timestamp\": \"2024-04-15T10:05:10Z\"}\n\nevent: task_status\ndata: {\"taskId\": \"task-abc-123\", \"state\": \"COMPLETED\", \"timestamp\": \"2024-04-15T10:05:15Z\", \"message\": \"Task finished successfully.\"}\n</code></pre>"},{"location":"a2a_profile_v0.2/#json-rpc-error-codes","title":"JSON-RPC Error Codes","text":"<p>Standard JSON-RPC codes MUST be used where applicable. AgentVault defines application-specific codes in the <code>-32000</code> to <code>-32099</code> range for agent-level errors.</p> Code Message Meaning Standard/App -32700 Parse error Invalid JSON received by the server. Standard -32600 Invalid Request The JSON sent is not a valid Request object. Standard -32601 Method not found The method does not exist / is not available. Standard -32602 Invalid Params Invalid method parameter(s). Standard -32603 Internal error Internal JSON-RPC error on the server. Standard -32000 Agent Server Error Generic application error on the agent. Application -32001 Task Not Found Specified <code>task_id</code> does not exist. Application -32002 Authentication Error API Key / Token invalid or missing. Application -32003 Authorization Error Authenticated user cannot perform action. Application -32004 Invalid State Operation not allowed in current task state. Application others Implementation Defined Server may define other -320xx errors. Application <p>Servers SHOULD include meaningful information in the <code>message</code> and optionally the <code>data</code> part of the error object. The client library (<code>A2ARemoteAgentError</code>) makes this information accessible.</p>"},{"location":"architecture/","title":"AgentVault Architecture","text":"<p>This document provides a high-level overview of the AgentVault ecosystem architecture, illustrating how the different components interact to enable secure agent discovery and communication.</p>"},{"location":"architecture/#vision","title":"Vision","text":"<p>AgentVault aims to be the open-source backbone for a thriving multi-agent ecosystem. It provides the standards, tools, and infrastructure necessary for agents built by anyone, anywhere, to find each other and collaborate effectively and securely.</p>"},{"location":"architecture/#component-overview","title":"Component Overview","text":"<p>The ecosystem consists of several distinct but interconnected Python packages and services:</p> <ol> <li><code>agentvault_library</code> (Core Client Library): The foundation for client-side interactions. Contains the <code>AgentVaultClient</code> (handles A2A protocol logic), <code>KeyManager</code> (secure credential storage), Pydantic models (AgentCard, A2A messages), and utility functions (card parsing, MCP handling). Used by the CLI and any custom application wanting to interact with agents.</li> <li><code>agentvault_cli</code> (Command Line Interface): The primary tool for end-users and developers to interact with the system from the terminal. Uses the <code>agentvault_library</code> to perform actions like configuring keys, discovering agents via the registry, and running tasks on agents.</li> <li><code>agentvault_registry</code> (Registry API &amp; UI): A central FastAPI web service acting as the discovery hub. It stores Agent Card metadata submitted by developers in a PostgreSQL database. It provides a public REST API (<code>/api/v1</code>) for searching/retrieving cards and an authenticated API for developers to manage their listings. It also serves a basic Web UI for public discovery (<code>/ui</code>) and developer management (<code>/ui/developer</code>).</li> <li><code>agentvault_server_sdk</code> (Server SDK): A toolkit for developers building A2A-compliant agents. Provides base classes (<code>BaseA2AAgent</code>), FastAPI integration helpers (<code>create_a2a_router</code>, <code>@a2a_method</code>), task state management abstractions, and packaging utilities (<code>agentvault-sdk package</code>) to simplify agent development and deployment.</li> <li><code>agentvault_testing_utils</code> (Testing Utilities): A shared internal package containing mocks, pytest fixtures, factories, and assertion helpers used across the test suites of the other components to ensure consistency and reduce boilerplate. Not intended for direct use by end-users.</li> </ol>"},{"location":"architecture/#interaction-flow-diagram","title":"Interaction Flow Diagram","text":"<pre><code>graph LR\n    subgraph User/Client Side\n        User[User / Client App] --&gt;|Uses| CLI(agentvault_cli)\n        CLI --&gt;|Uses| Lib(agentvault_library)\n        User --&gt;|Uses| Lib\n        Lib --&gt;|Manages Keys via KeyManager| KeyStore[Local Credential Store Env/File/Keyring]\n    end\n\n    subgraph Developer Side\n        Dev[Agent Developer] --&gt;|Uses| SDK(agentvault_server_sdk)\n        SDK --&gt;|Builds Agent + Card| AgentServer(A2A Agent Server FastAPI)\n        Dev --&gt;|Creates/Manages Registry Key| DevKeyStore[Developer API Key Stored by Dev]\n        Dev --&gt;|Submits Card via API Uses DevKeyStore| RegistryAPI(Registry API /api/v1)\n    end\n\n    subgraph Central Service\n        RegistryAPI --&gt;|Reads/Writes Hashes| DB[Registry DB Cards Hashed Keys]\n        RegistryAPI --&gt;|Serves UI| RegistryUI(Registry Web UI /ui)\n        User --&gt;|Browses| RegistryUI\n    end\n\n    subgraph Communication Paths\n        Lib --&gt;|Discover Agent Public API| RegistryAPI\n        Lib --&gt;|Get Agent Card Public API| RegistryAPI\n        Lib --&gt;|Run Task A2A Protocol| AgentServer\n        AgentServer --&gt;|Optional: Uses Lib/SDK| ExternalService[External APIs / Services]\n    end\n\n    style Dev fill:#ff99ff,stroke:#333333,stroke-width:2px\n    style User fill:#ccccff,stroke:#333333,stroke-width:2px\n    style KeyStore stroke-dasharray: 5 5\n    style DevKeyStore stroke-dasharray: 5 5</code></pre> <p>Explanation of Flows:</p> <ol> <li>Discovery: A user or client application (using the Library or CLI) queries the Registry API's public endpoints (<code>/api/v1/...</code>) or browses the public Web UI (<code>/ui</code>) to find agents based on criteria.</li> <li>Card Retrieval: The client retrieves the specific Agent Card for the desired agent from the Registry API (public endpoint).</li> <li>Interaction (Client -&gt; Agent):<ul> <li>The client application uses the information in the retrieved Agent Card (endpoint <code>url</code>, <code>authSchemes</code>).</li> <li>The <code>agentvault_library</code>'s <code>KeyManager</code> component attempts to load the necessary local credentials.</li> <li>The <code>AgentVaultClient</code> constructs and sends A2A protocol requests directly to the target Agent Server's endpoint, automatically adding required authentication headers.</li> <li>The Agent Server receives the request, authenticates it, processes the task, and sends back responses/events.</li> </ul> </li> <li>Registration (Developer -&gt; Registry):<ul> <li>The Agent Developer uses their unique Developer API Key with the authenticated endpoints of the Registry API (<code>/api/v1/...</code>) or potentially the Developer Portal UI (<code>/ui/developer</code>) to submit or manage their Agent Cards.</li> <li>The Registry API verifies the key against stored hashes.</li> </ul> </li> </ol>"},{"location":"architecture/#key-architectural-principles","title":"Key Architectural Principles","text":"<ul> <li>Decentralized Execution: Agents run independently. The Registry is only for discovery metadata.</li> <li>Standardized Interface: Communication relies on the defined AgentVault A2A Profile v0.2 and the <code>AgentCard</code> schema.</li> <li>Component-Based: Logical components (library, CLI, registry, SDK, testing utils) with distinct responsibilities.</li> <li>Security Focus: Secure credential management, hashed keys, HTTPS enforcement, TEE awareness.</li> <li>Developer Experience: SDK and CLI tools simplify common tasks.</li> </ul>"},{"location":"concepts/","title":"Core Concepts","text":"<p>This page defines the key concepts and terminology used throughout the AgentVault ecosystem. Understanding these concepts is crucial for effectively using the tools and contributing to the project.</p>"},{"location":"concepts/#agent-card","title":"Agent Card","text":"<ul> <li>Definition: A standardized JSON document (typically named <code>agent-card.json</code>) containing metadata that describes an A2A-compliant agent. It's the agent's \"business card\" for the digital world.</li> <li>Purpose: Enables discovery via the AgentVault Registry and provides essential information for clients (other agents or applications) to connect, authenticate, and interact with the agent.</li> <li>Schema: The structure and required fields are defined by the <code>agentvault.models.AgentCard</code> Pydantic model, aligning with emerging A2A standards. See the A2A Profile v0.2 for protocol details derived from the card.</li> <li>Key Fields: Includes the agent's unique <code>humanReadableId</code>, display <code>name</code>, <code>description</code>, the A2A endpoint <code>url</code>, technical <code>capabilities</code> (like supported protocol versions, TEE usage), required <code>authSchemes</code>, and details about the <code>provider</code>.</li> </ul>"},{"location":"concepts/#agent-to-agent-a2a-protocol","title":"Agent-to-Agent (A2A) Protocol","text":"<ul> <li>Definition: The standardized communication protocol enabling direct interaction between AgentVault clients and A2A-compliant agent servers. It defines the methods, message formats, and interaction patterns.</li> <li>Based On: Inspired by and aligned with concepts from the Google A2A Protocol specification, utilizing JSON-RPC 2.0 over HTTP POST for requests and Server-Sent Events (SSE) over HTTP for asynchronous streaming updates.</li> <li>Key Methods: Defines standard operations like initiating tasks (<code>tasks/send</code>), retrieving task status (<code>tasks/get</code>), requesting cancellation (<code>tasks/cancel</code>), and subscribing to real-time updates (<code>tasks/sendSubscribe</code>).</li> <li>Profile: The specific implementation details, method signatures, payload structures, and state transitions used within AgentVault are documented in the AgentVault A2A Profile v0.2.</li> </ul>"},{"location":"concepts/#model-context-protocol-mcp","title":"Model Context Protocol (MCP)","text":"<ul> <li>Definition: (Conceptual / Future Work) A protocol intended for exchanging richer, structured contextual information between agents beyond simple text prompts. This might include user profiles, conversation history summaries, references to external data, or task-specific parameters.</li> <li>Status: Currently in the conceptual phase within AgentVault. The <code>agentvault_library</code> provides basic utilities (<code>mcp_utils.py</code>) for embedding arbitrary context data within the <code>metadata['mcp_context']</code> field of A2A <code>Message</code> objects. A formal MCP specification is planned for future development, potentially aligning with external standards if they emerge.</li> <li>Goal: To enable more sophisticated, context-aware collaboration and task handoff between specialized agents.</li> </ul>"},{"location":"concepts/#agentvault-registry","title":"AgentVault Registry","text":"<ul> <li>Definition: A central API service (<code>agentvault_registry</code>) and web UI acting as the discovery hub for the ecosystem. Developers register their agents by submitting Agent Cards, and clients query the registry to find agents based on various criteria.</li> <li>Component: <code>agentvault_registry</code></li> <li>Features: Public REST API for listing, searching (by name, description, tags, TEE support), and retrieving Agent Cards. Authenticated REST API for developers to submit, update, and deactivate their cards. Includes Agent Card validation against the core library's schema, developer verification status tracking, and a basic web UI for discovery and developer management. See the Registry API Guide.</li> </ul>"},{"location":"concepts/#agentvault-library-client","title":"AgentVault Library (Client)","text":"<ul> <li>Definition: The core Python library (<code>agentvault</code>) providing the client-side tools needed to interact with the ecosystem.</li> <li>Component: <code>agentvault_library</code></li> <li>Features: Provides the <code>AgentVaultClient</code> for making A2A calls (handling JSON-RPC, SSE, authentication), the <code>KeyManager</code> for secure local credential handling (API keys, OAuth credentials), utilities for Agent Card parsing and validation (<code>agent_card_utils</code>), basic MCP context embedding helpers (<code>mcp_utils</code>), and Pydantic models defining all necessary data structures (<code>agentvault.models</code>). See the Library Guide.</li> </ul>"},{"location":"concepts/#agentvault-server-sdk","title":"AgentVault Server SDK","text":"<ul> <li>Definition: A Python Software Development Kit (<code>agentvault-server-sdk</code>) designed to accelerate the development of A2A-compliant agent servers.</li> <li>Component: <code>agentvault_server_sdk</code></li> <li>Features: Includes the <code>BaseA2AAgent</code> abstract class, FastAPI integration helpers (<code>create_a2a_router</code>, <code>@a2a_method</code> decorator) to automatically expose agent logic via the A2A protocol, abstractions for task state management (<code>BaseTaskStore</code>, <code>InMemoryTaskStore</code>), utilities for handling MCP context server-side, and a command-line tool (<code>agentvault-sdk package</code>) for packaging agents into Docker containers. See the Server SDK Guide.</li> </ul>"},{"location":"concepts/#agentvault-cli","title":"AgentVault CLI","text":"<ul> <li>Definition: A command-line interface (<code>agentvault-cli</code>) providing a user-friendly way to interact with AgentVault features.</li> <li>Component: <code>agentvault_cli</code></li> <li>Features: Allows users to manage local credentials (<code>config</code>), discover agents in the registry (<code>discover</code>), and execute tasks on remote agents (<code>run</code>). Built using the <code>agentvault</code> library. See the CLI User Guide.</li> </ul>"},{"location":"concepts/#keymanager","title":"KeyManager","text":"<ul> <li>Definition: A component within the <code>agentvault_library</code> responsible for securely loading, storing (optionally via OS keyring), and retrieving credentials (API keys, OAuth Client ID/Secrets) needed by the <code>AgentVaultClient</code> to authenticate with remote agents.</li> <li>Component: Part of <code>agentvault_library</code> (<code>key_manager.py</code>)</li> <li>Sources: Loads credentials based on a priority order: specified file (<code>.env</code> or <code>.json</code>) &gt; environment variables &gt; OS keyring (if enabled and available).</li> <li>Lookup: Uses a Service Identifier to find the correct credential set for a given agent.</li> </ul>"},{"location":"concepts/#service-identifier","title":"Service Identifier","text":"<ul> <li>Definition: A string used by the <code>KeyManager</code> to look up the correct local credentials (API Key or OAuth Client ID/Secret) for a specific agent or service. It acts as a local alias for a credential set.</li> <li>Source: Can be explicitly defined in an agent's <code>AgentCard</code> within the <code>authSchemes[].service_identifier</code> field. If omitted in the card, clients (like the CLI) might default to using the agent's <code>humanReadableId</code> or require the user to specify an override (e.g., via <code>agentvault_cli run --key-service &lt;your_local_id&gt;</code>).</li> <li>Purpose: Allows a single credential (like an OpenAI key) stored locally under one <code>service_identifier</code> (e.g., \"openai\") to be used by multiple different agents that all require OpenAI authentication, even if their <code>humanReadableId</code>s differ.</li> </ul>"},{"location":"concepts/#trusted-execution-environment-tee","title":"Trusted Execution Environment (TEE)","text":"<ul> <li>Definition: A secure, isolated environment within a computer's processor that provides hardware-level guarantees for the confidentiality and integrity of code and data executed within it. Examples include Intel SGX, AMD SEV, AWS Nitro Enclaves.</li> <li>Relevance: Agents can optionally run within a TEE to enhance security and provide verifiable guarantees about their execution environment. Agent Cards can declare TEE usage (<code>capabilities.teeDetails</code>) including the type and potentially an attestation endpoint. The registry allows filtering for TEE-enabled agents.</li> <li>Current Scope: AgentVault currently supports the declaration and discovery of TEE capabilities. Automated verification of TEE attestations during A2A communication is a planned future enhancement. See the TEE Profile.</li> </ul>"},{"location":"examples/","title":"AgentVault Examples","text":"<p>This section provides practical examples demonstrating how to use the various components of the AgentVault ecosystem.</p> <p>These examples are designed to help you get started quickly, whether you are building an A2A-compliant agent, using the client library to interact with agents, or utilizing the command-line interface.</p>"},{"location":"examples/#available-examples","title":"Available Examples","text":"<p>The source code for these examples can be found in the <code>/examples/</code> directory of the AgentVault GitHub repository.</p> <ul> <li> <p>Basic A2A Server: (View Code)</p> <ul> <li>Focus: Demonstrates the minimal setup required to create an A2A-compliant agent server using the <code>agentvault-server-sdk</code> and FastAPI.</li> <li>Features: Implements a simple \"EchoAgent\", uses the SDK's router integration (<code>create_a2a_router</code>), includes a basic <code>agent-card.json</code>, and shows how to run the server with Uvicorn.</li> <li>Good for: Developers starting to build their first A2A agent.</li> </ul> </li> <li> <p>LangChain Integration: (View Code)</p> <ul> <li>Focus: Shows how to wrap an AgentVault A2A agent as a custom <code>Tool</code> within the LangChain framework.</li> <li>Features: Defines an <code>A2AAgentTool</code> class that uses the <code>agentvault</code> client library internally to communicate with a remote agent based on an agent reference (ID, URL, or file path). Includes example usage.</li> <li>Good for: Developers wanting to integrate existing or new A2A agents into LangChain applications and agentic workflows.</li> </ul> </li> <li> <p>OAuth Agent Example: (View Code)</p> <ul> <li>Focus: Demonstrates implementing the <code>oauth2</code> (Client Credentials) authentication scheme using the Server SDK and FastAPI.</li> <li>Features: Includes a custom <code>/token</code> endpoint, uses environment variables for mock credentials, and protects the <code>/a2a</code> endpoint using a FastAPI dependency.</li> <li>Good for: Developers needing to implement OAuth2 authentication for their agents.</li> </ul> </li> <li> <p>Stateful Agent Example: (View Code)</p> <ul> <li>Focus: Demonstrates managing task state (like chat history) across multiple client interactions within a single task ID using the Server SDK.</li> <li>Features: Uses a custom <code>TaskContext</code> subclass, <code>InMemoryTaskStore</code>, and <code>asyncio.Event</code> to handle multi-turn interactions and background processing.</li> <li>Good for: Developers building conversational agents or agents that require maintaining context over several requests.</li> </ul> </li> <li> <p>Direct Library Usage: (View Code)</p> <ul> <li>Focus: Shows how to use the <code>agentvault</code> client library directly in a Python script to interact with an agent.</li> <li>Features: Demonstrates loading agent cards, using <code>KeyManager</code>, calling <code>AgentVaultClient</code> methods (<code>initiate_task</code>, <code>receive_messages</code>), and handling events and errors.</li> <li>Good for: Developers integrating AgentVault client functionality into custom applications or scripts.</li> </ul> </li> </ul>"},{"location":"examples/#running-the-examples","title":"Running the Examples","text":"<p>Please refer to the <code>README.md</code> file within each specific example directory (linked via \"[View Code]\" above) for detailed setup and execution instructions. Generally, you will need to:</p> <ol> <li>Ensure you have the main development environment set up (see Installation Guide).</li> <li>Navigate to the specific example directory (e.g., <code>cd examples/basic_a2a_server</code>).</li> <li>Install any example-specific requirements (usually via <code>pip install -r requirements.txt</code>).</li> <li>Follow the instructions in the example's <code>README.md</code> to run the server or script.</li> </ol> <p>We encourage you to explore these examples and adapt them for your own use cases!</p>"},{"location":"installation/","title":"Installation Guide","text":"<p>This guide covers how to install the different parts of the AgentVault ecosystem, depending on your needs.</p>"},{"location":"installation/#1-installing-for-usage-cli-client-library","title":"1. Installing for Usage (CLI &amp; Client Library)","text":"<p>If you want to use the AgentVault CLI to interact with agents or use the <code>agentvault</code> client library in your own Python projects, install directly from PyPI.</p> <p>Prerequisites:</p> <ul> <li>Python 3.10 or 3.11 installed.</li> <li><code>pip</code> (Python's package installer).</li> </ul> <p>Installation Options:</p> <ul> <li> <p>CLI Only: <pre><code>pip install agentvault-cli\n</code></pre> To include optional OS Keyring support for secure credential storage: <pre><code>pip install \"agentvault-cli[os_keyring]\"\n</code></pre></p> </li> <li> <p>Client Library Only (<code>agentvault</code>): <pre><code>pip install agentvault\n</code></pre> To include optional OS Keyring support: <pre><code>pip install \"agentvault[os_keyring]\"\n</code></pre></p> </li> <li> <p>Server SDK Only (<code>agentvault-server-sdk</code>): (Note: This also installs the <code>agentvault</code> client library as a dependency) <pre><code>pip install agentvault-server-sdk\n</code></pre></p> </li> </ul> <p>Verification (CLI):</p> <p>After installing the CLI, check that the command is available:</p> <pre><code>agentvault_cli --version\n</code></pre> <p>Connecting to the Public Registry:</p> <p>You can use the installed CLI or library with the publicly hosted registry:</p> <ul> <li>URL: <code>https://agentvault-registry-api.onrender.com</code></li> <li>Usage:<ul> <li>Set the environment variable: <code>export AGENTVAULT_REGISTRY_URL=https://agentvault-registry-api.onrender.com</code> (Linux/macOS) or <code>set AGENTVAULT_REGISTRY_URL=https://agentvault-registry-api.onrender.com</code> (Windows Cmd) or <code>$env:AGENTVAULT_REGISTRY_URL='https://agentvault-registry-api.onrender.com'</code> (PowerShell).</li> <li>Or use the <code>--registry</code> flag with CLI commands: <code>agentvault_cli discover --registry https://agentvault-registry-api.onrender.com</code></li> </ul> </li> <li>Note (Cold Start): This instance runs on Render's free tier. If it hasn't received traffic recently, it might take up to 60 seconds to respond to the first request while it \"wakes up\". Subsequent requests will be faster. You can send a simple request like <code>curl https://agentvault-registry-api.onrender.com/health</code> to wake it up before running commands if needed.</li> </ul>"},{"location":"installation/#2-setting-up-for-development-contributing-or-running-from-source","title":"2. Setting up for Development (Contributing or Running from Source)","text":"<p>If you want to contribute to AgentVault, run components locally from the source code (like the registry), or use features not yet released on PyPI, follow these steps. This sets up the entire monorepo.</p> <p>Prerequisites:</p> <ul> <li>Git</li> <li>Python 3.10 or 3.11</li> <li>Poetry (Python dependency management and packaging tool)</li> <li>PostgreSQL Server (Required only if running the <code>agentvault_registry</code> locally).</li> </ul> <p>Steps:</p> <ol> <li> <p>Clone the Repository: <pre><code>git clone https://github.com/SecureAgentTools/AgentVault.git\ncd AgentVault\n</code></pre></p> </li> <li> <p>Install Dependencies (including Development Tools): Navigate to the project root (<code>AgentVault/</code>) and use Poetry to install all dependencies for all workspace packages:     <pre><code># Installs production AND development dependencies (pytest, httpx, mkdocs, etc.)\npoetry install --with dev\n\n# To include optional OS Keyring support for development:\n# poetry install --with dev --extras os_keyring\n</code></pre></p> <ul> <li>This command reads the <code>pyproject.toml</code> files in each component directory (<code>agentvault_library</code>, <code>agentvault_cli</code>, etc.).</li> <li>It resolves all dependencies across the workspace.</li> <li>It installs everything into a single virtual environment located in the project root (usually <code>.venv/</code>).</li> </ul> </li> <li> <p>Activate Virtual Environment: Before running any commands or tests from source, activate the environment created by Poetry:</p> <ul> <li>Linux/macOS (bash/zsh): <pre><code>source .venv/bin/activate\n</code></pre></li> <li>Windows (PowerShell): <pre><code>.\\.venv\\Scripts\\Activate.ps1\n</code></pre></li> <li>Windows (Command Prompt): <pre><code>.\\.venv\\Scripts\\activate.bat\n</code></pre> You should see <code>(.venv)</code> appear at the beginning of your command prompt line.</li> </ul> </li> <li> <p>Verify Installation: You can now run commands from different components, e.g.:     <pre><code># Check CLI version (running from source)\nagentvault_cli --version\n# Run library tests\npytest agentvault_library/tests/\n# Check docs tool\nmkdocs --version\n</code></pre></p> </li> </ol>"},{"location":"installation/#3-running-the-registry-local-development","title":"3. Running the Registry (Local Development)","text":"<p>To run the <code>agentvault_registry</code> API locally (e.g., for testing agents or the CLI against it):</p> <ol> <li>Complete Development Setup: Follow the steps in section 2 above. Ensure you have a running PostgreSQL server accessible.</li> <li>Navigate: <pre><code>cd agentvault_registry\n</code></pre></li> <li>Configure Database &amp; Secrets:<ul> <li>Copy <code>.env.example</code> to <code>.env</code> (if it exists) or create a <code>.env</code> file in the <code>agentvault_registry/</code> directory.</li> <li>Set the <code>DATABASE_URL</code> environment variable in the <code>.env</code> file to point to your local PostgreSQL instance (ensure it uses the <code>asyncpg</code> driver, e.g., <code>postgresql+asyncpg://user:pass@host:port/dbname</code>).</li> <li>Set the <code>API_KEY_SECRET</code> environment variable in the <code>.env</code> file (generate a strong secret, e.g., <code>openssl rand -hex 32</code>).</li> </ul> </li> <li>Database Setup:<ul> <li>Ensure your PostgreSQL server is running and the specified database exists.</li> <li>Run database migrations using Alembic (make sure your virtual environment is activated):     <pre><code># Run from the agentvault_registry/ directory\nalembic upgrade head\n</code></pre></li> </ul> </li> <li>Run the Server: Use Uvicorn (which was installed as part of development dependencies):     <pre><code># Run from the agentvault_registry/ directory\nuvicorn agentvault_registry.main:app --reload --host 0.0.0.0 --port 8000\n</code></pre><ul> <li><code>--reload</code>: Automatically restarts the server when code changes.</li> <li><code>--host 0.0.0.0</code>: Makes the server accessible from other devices on your network (use <code>127.0.0.1</code> for localhost only).</li> <li><code>--port 8000</code>: The default port.</li> </ul> </li> </ol> <p>The registry API should now be running at <code>http://localhost:8000</code>. You can access the API docs at <code>http://localhost:8000/docs</code>.</p>"},{"location":"privacy_policy/","title":"AgentVault Registry API - Privacy Policy","text":"<p>Last Updated: [April 12, 2025]</p> <p>This Privacy Policy describes how the AgentVault Project Maintainers (\"we\", \"us\", \"our\") collect, use, and handle information in connection with your use of the AgentVault Registry API (the \"Service\").</p> <p>1. Data Controller</p> <p>The data controller for the information processed via the Service is The AgentVault Project Maintainers. You can contact us regarding privacy matters at:</p> <p><code>[CONTACT_EMAIL_PLACEHOLDER]</code></p> <p>[IMPORTANT NOTE]: This email address is a placeholder and MUST be replaced with the actual project contact email before public release.</p> <p>2. Information We Collect</p> <p>We collect the following types of information:</p> <ul> <li> <p>Information Provided by Developers:</p> <ul> <li>Developer Name: When a developer account is created or associated with an API key (process TBD).</li> <li>Hashed API Key: We store a cryptographically hashed version of the API key assigned to developers for authentication purposes. We never store the plain-text API key after initial generation and verification.</li> <li>Agent Card Metadata: The full JSON content of Agent Cards submitted by developers, which may include agent names, descriptions, endpoint URLs, provider details, etc., as defined by the A2A Agent Card schema.</li> <li>(Optional - If Implemented Later): Developer Email Address: If we implement features requiring direct communication (e.g., account recovery, important service notifications), we may collect developer email addresses. This will be clearly indicated at the time of collection.</li> </ul> </li> <li> <p>Information Collected Automatically:</p> <ul> <li>Log Data: Like most web services, our servers automatically record information (\"Log Data\") created by your use of the Service. Log Data may include information such as your IP address, browser type, operating system, the referring web page, pages visited, location (if enabled by your browser), device information, search terms (for the registry search endpoint), and cookie information (if applicable, though the API itself likely doesn't use persistent cookies). We use Log Data for security monitoring, service operation, debugging, and aggregated analytics.</li> </ul> </li> </ul> <p>3. How We Use Information</p> <p>We use the information we collect for the following purposes:</p> <ul> <li>To Provide and Maintain the Service: To operate the registry, allow agent discovery, authenticate developers, store and serve Agent Cards.</li> <li>To Improve the Service: To analyze usage patterns (using aggregated/anonymized data where possible) to understand how the Service is used and identify areas for improvement.</li> <li>To Ensure Security: To monitor for and prevent fraudulent activity, abuse, and security incidents. To verify developer identities via API keys.</li> <li>To Communicate (If Applicable): If we collect email addresses, we may use them to communicate important service updates, security notices, or respond to support requests or reports. We will provide opt-out mechanisms for non-essential communications.</li> <li>To Comply with Law: To comply with applicable legal obligations, regulations, or valid legal processes.</li> </ul> <p>4. Data Sharing and Disclosure</p> <ul> <li>Public Agent Card Data: The Agent Card metadata submitted by developers (excluding potentially sensitive internal details not part of the standard schema display) is intended to be publicly accessible via the API for discovery purposes.</li> <li>Service Providers: We may engage third-party companies or individuals as service providers (e.g., hosting providers, database providers) to process information on our behalf based on our instructions and in compliance with this Privacy Policy and appropriate confidentiality and security measures.</li> <li>Legal Requirements: We may disclose information if required to do so by law or in the good faith belief that such action is necessary to comply with a legal obligation, protect and defend our rights or property, prevent fraud, act in urgent circumstances to protect the personal safety of users of the Service or the public, or protect against legal liability.</li> <li>Aggregated/Anonymized Data: We may share aggregated or anonymized information (which does not identify individuals) for research, analytics, or reporting purposes.</li> <li>We do not sell developer personal information.</li> </ul> <p>5. Data Security</p> <p>We implement reasonable technical and organizational measures to protect the information we collect from loss, misuse, unauthorized access, disclosure, alteration, and destruction. This includes using HTTPS for API communication and hashing developer API keys. However, no internet transmission or electronic storage is 100% secure.</p> <p>6. Data Retention</p> <p>We retain information for as long as necessary to fulfill the purposes outlined in this Privacy Policy unless a longer retention period is required or permitted by law.</p> <ul> <li>Developer Information: Retained as long as the developer account is active or as needed for operational purposes.</li> <li>Agent Card Data: Retained as long as the card is active or for a reasonable period after deactivation for archival purposes, unless requested otherwise by the developer under their rights.</li> <li>Log Data: Typically retained for a limited period (e.g., 30-90 days) for security and debugging purposes, unless required for ongoing investigations or legal obligations.</li> </ul> <p>7. Your Rights (GDPR and other applicable laws)</p> <p>Depending on your location, you may have certain rights regarding your personal information, including:</p> <ul> <li>The right to access the personal information we hold about you.</li> <li>The right to request correction of inaccurate personal information.</li> <li>The right to request erasure of your personal information (subject to legal/operational constraints).</li> <li>The right to object to or restrict processing of your personal information.</li> <li>The right to data portability.</li> </ul> <p>To exercise these rights, please contact us at:</p> <p><code>[CONTACT_EMAIL_PLACEHOLDER]</code></p> <p>[IMPORTANT NOTE]: This email address is a placeholder and MUST be replaced with the actual project contact email before public release.</p> <p>We will respond to your request consistent with applicable law.</p> <p>8. International Data Transfers</p> <p>The Service may be hosted and operated in jurisdictions outside of your own. By using the Service, you consent to the transfer of your information to these jurisdictions, which may have data protection rules that are different from those of your country.</p> <p>9. Children's Privacy</p> <p>The Service is not directed to individuals under the age of 16 (or the relevant age of digital consent in your jurisdiction). We do not knowingly collect personal information from children. If we become aware that a child has provided us with personal information, we will take steps to delete such information.</p> <p>10. Changes to This Privacy Policy</p> <p>We may update this Privacy Policy from time to time. If we make material changes, we will notify you by updating the \"Last Updated\" date at the top of this policy and potentially through other means (e.g., a notice on a project website or mailing list, if available). We encourage you to review this policy periodically.</p> <p>11. Contact Us</p> <p>If you have any questions about this Privacy Policy, please contact us at:</p> <p><code>[CONTACT_EMAIL_PLACEHOLDER]</code></p> <p>[IMPORTANT NOTE]: This email address is a placeholder and MUST be replaced with the actual project contact email before public release.</p>"},{"location":"security/","title":"AgentVault Security Considerations","text":"<p>Note: For the official security policy and vulnerability reporting process, please see the Security Policy document.</p> <p>This document details the security mechanisms, considerations, and best practices... Security is a fundamental aspect of the AgentVault ecosystem, designed to enable trustworthy interactions between agents and protect user/developer credentials. This document details the security mechanisms, considerations, and best practices.</p>"},{"location":"security/#authentication","title":"Authentication","text":"<p>Authentication verifies the identity of the communicating parties. AgentVault employs different mechanisms for client-to-agent and developer-to-registry interactions.</p>"},{"location":"security/#1-client-to-agent-authentication-a2a","title":"1. Client-to-Agent Authentication (A2A)","text":"<p>Agents declare how clients should authenticate in their <code>AgentCard</code> (<code>authSchemes</code>). The <code>agentvault</code> library (used by the CLI and custom clients) supports:</p> <ul> <li><code>none</code>:<ul> <li>Mechanism: No authentication headers are sent.</li> <li>Use Case: Suitable for public agents providing non-sensitive information or actions.</li> <li>Security: Offers no protection against unauthorized access. Use only when the agent's functionality requires no access control.</li> </ul> </li> <li><code>apiKey</code>:<ul> <li>Mechanism: The client sends a pre-shared secret key in the <code>X-Api-Key</code> HTTP header.</li> <li>Client-Side: The <code>agentvault</code> library's <code>KeyManager</code> retrieves the key associated with the agent's <code>service_identifier</code> from local storage (env, file, or OS keyring).</li> <li>Server-Side: The agent server (implementer) is responsible for receiving the <code>X-Api-Key</code> header and validating the key against its own secure storage (e.g., environment variable, configuration management system, database with hashed keys). Never hardcode keys in agent source code.</li> <li>Security: Relies on the secrecy of the key and secure transport (HTTPS). Simpler to implement but less flexible than OAuth.</li> </ul> </li> <li><code>oauth2</code> (Client Credentials Grant):<ul> <li>Mechanism: The client uses its own credentials (Client ID &amp; Secret) to obtain a short-lived Bearer token from the agent's designated Token Endpoint (<code>tokenUrl</code> in Agent Card), then uses that token for subsequent A2A requests.</li> <li>Client-Side: <code>KeyManager</code> retrieves the Client ID/Secret for the agent's <code>service_identifier</code>. <code>AgentVaultClient</code> performs the POST request to the <code>tokenUrl</code> to get the <code>access_token</code> and caches it (in memory). It sends the token in the <code>Authorization: Bearer &lt;token&gt;</code> header.</li> <li>Server-Side: The agent server must provide a <code>/token</code> endpoint compliant with the OAuth 2.0 Client Credentials grant flow. It validates the received Client ID/Secret and issues a signed, potentially short-lived Bearer token (e.g., a JWT). The main <code>/a2a</code> endpoint must then validate incoming Bearer tokens (check signature, expiry, audience, scopes if applicable).</li> <li>Security: More complex but standard-based. Allows for token revocation, scopes, and avoids sending long-lived secrets directly to the agent endpoint after initial token exchange. Requires secure handling of Client ID/Secret on the client and robust token validation on the server.</li> </ul> </li> <li><code>bearer</code>:<ul> <li>Mechanism: The client sends a pre-existing Bearer token in the <code>Authorization: Bearer &lt;token&gt;</code> header.</li> <li>Client-Side: Assumes the client application has obtained a suitable token through some other means (e.g., user login flow, separate OAuth process). The <code>agentvault</code> library simply passes this token along if configured.</li> <li>Server-Side: The agent server must validate the received Bearer token.</li> <li>Security: Depends entirely on the security of the token issuance and validation process external to the basic A2A interaction.</li> </ul> </li> </ul>"},{"location":"security/#2-developer-to-registry-authentication","title":"2. Developer-to-Registry Authentication","text":"<ul> <li>Mechanism: Uses an API Key (<code>X-Api-Key</code> header) specific to the developer.</li> <li>Key Generation: Keys are generated by registry administrators (currently manual, future portal TBD) using <code>secrets.token_urlsafe</code> and prefixed (<code>avreg_</code>).</li> <li>Storage: The hash of the developer's API key is stored in the registry database (<code>Developer.api_key_hash</code>) using <code>passlib</code> with <code>bcrypt</code>. Plain text keys are never stored.</li> <li>Verification: The registry API uses <code>passlib.verify(plain_key, stored_hash)</code> to authenticate developers attempting to manage their Agent Cards.</li> <li>Security: Relies on the developer keeping their plain-text key secret and secure transport (HTTPS). Hashing prevents exposure of the plain key even if the database is compromised. The current lookup method iterates hashes, which is a scalability concern but not a direct security flaw for moderate numbers of developers.</li> </ul>"},{"location":"security/#credential-management-keymanager","title":"Credential Management (<code>KeyManager</code>)","text":"<p>The <code>agentvault</code> library's <code>KeyManager</code> provides a unified way for clients (like the CLI) to manage credentials needed for agent authentication.</p> <ul> <li>Secure Storage: Strongly recommends using the OS Keyring (<code>--keyring</code> option in CLI <code>config set</code>) for storing sensitive API keys and OAuth secrets. This leverages platform-specific secure storage mechanisms.</li> <li>Alternative Sources: Supports loading from environment variables and <code>.env</code>/<code>.json</code> files for flexibility, but users should be aware of the security implications of storing secrets in these locations (filesystem permissions, environment variable visibility).</li> <li>Abstraction: Client code interacts with <code>KeyManager</code> (<code>get_key</code>, <code>get_oauth_client_id</code>, etc.) without needing to know where the credential came from.</li> </ul>"},{"location":"security/#transport-security","title":"Transport Security","text":"<ul> <li>HTTPS is MANDATORY for all communication with the AgentVault Registry API and any A2A agent endpoint not running on <code>localhost</code>.</li> <li>Agent Card <code>url</code> and <code>tokenUrl</code> fields should use <code>https://</code>.</li> <li>Failure to use HTTPS exposes authentication credentials (API keys, Bearer tokens) and message content to eavesdropping.</li> </ul>"},{"location":"security/#data-validation","title":"Data Validation","text":"<ul> <li>Pydantic: All components heavily utilize Pydantic models for defining data structures (Agent Cards, API request/response bodies, A2A messages). Pydantic performs automatic data validation on input, preventing many types of injection or malformed data errors.</li> <li>Registry: Validates submitted <code>card_data</code> against the canonical <code>agentvault.models.AgentCard</code> schema before storing it.</li> <li>Server SDK: The <code>create_a2a_router</code> automatically validates incoming JSON-RPC <code>params</code> against the type hints of the corresponding agent handler method.</li> </ul>"},{"location":"security/#rate-limiting","title":"Rate Limiting","text":"<ul> <li>Registry: Implements basic IP-based rate limiting using <code>slowapi</code> to mitigate simple denial-of-service and abuse patterns. Production deployments may require more sophisticated limiting.</li> <li>Agents: Agent developers are responsible for implementing appropriate rate limiting on their own A2A endpoints if needed.</li> </ul>"},{"location":"security/#trusted-execution-environments-tee","title":"Trusted Execution Environments (TEE)","text":"<ul> <li>Declaration: Agent Cards can declare (<code>capabilities.teeDetails</code>) that an agent runs within a TEE, providing metadata like the TEE type and potentially an attestation endpoint URL.</li> <li>Discovery: The registry allows filtering agents based on TEE support.</li> <li>Verification (Future Work): Currently, AgentVault clients do not automatically verify TEE attestations. Implementing robust, automated attestation verification and potentially establishing secure channels based on TEE keys is a complex task planned for future development. Users currently rely on the agent's declaration and must perform any verification manually or through out-of-band mechanisms.</li> </ul>"},{"location":"security/#dependency-security","title":"Dependency Security","text":"<ul> <li>Auditing: The project includes a GitHub Actions workflow (<code>dependency_audit.yml</code>) using <code>pip-audit</code> to automatically scan dependencies listed in <code>poetry.lock</code> files for known vulnerabilities on pushes/PRs to <code>main</code>.</li> <li>Updates: Regularly updating dependencies (e.g., via <code>poetry update</code>) is crucial to patch vulnerabilities.</li> </ul>"},{"location":"security/#reporting-vulnerabilities","title":"Reporting Vulnerabilities","text":"<p>Please report suspected security vulnerabilities privately according to the Security Policy.</p>"},{"location":"security_policy/","title":"Security Policy for AgentVault","text":""},{"location":"security_policy/#introduction","title":"Introduction","text":"<p>The AgentVault project prioritizes security. We appreciate the efforts of security researchers and the community in helping us maintain a secure ecosystem. This document outlines our policy for reporting security vulnerabilities.</p>"},{"location":"security_policy/#scope","title":"Scope","text":"<p>This policy applies to the following components and repositories within the AgentVault project:</p> <ul> <li><code>agentvault</code> (Core Library): Located in the <code>agentvault_library/</code> directory.</li> <li><code>agentvault-registry</code> (Registry API): Located in the <code>agentvault_registry/</code> directory.</li> <li><code>agentvault-cli</code> (CLI Client): Located in the <code>agentvault_cli/</code> directory.</li> <li><code>agentvault-server-sdk</code> (Server SDK): Located in the <code>agentvault_server_sdk/</code> directory.</li> </ul> <p>Vulnerabilities discovered in third-party agents listed in the registry should be reported directly to the respective agent provider according to their own security policy. The AgentVault registry itself only stores metadata.</p>"},{"location":"security_policy/#reporting-a-vulnerability","title":"Reporting a Vulnerability","text":"<p>We appreciate responsible disclosure. Please report any suspected security vulnerabilities privately to ensure the security of our users and the ecosystem.</p> <p>Preferred Method:</p> <ul> <li> <p>GitHub Private Vulnerability Reporting: If you are reporting via GitHub, please use the built-in \"Report a vulnerability\" feature within the main AgentVault repository. This allows for secure communication and tracking.</p> <p><code>[LINK_TO_GITHUB_SECURITY_TAB_PLACEHOLDER]</code></p> <p>[IMPORTANT NOTE]: This link is a placeholder and MUST be replaced with the actual URL to the repository's Security tab once available.</p> </li> </ul> <p>Alternative Method:</p> <ul> <li> <p>Email: If you cannot use GitHub's reporting feature, you can email your report to:</p> <p><code>[CONTACT_EMAIL_PLACEHOLDER]</code></p> <p>[IMPORTANT NOTE]: This email address is a placeholder and MUST be replaced with the actual project security contact email before public release. Use this for vulnerability reports ONLY.</p> <p>Use a clear subject line like \"Security Vulnerability Report: AgentVault [Component Name]\".</p> </li> </ul> <p>What to Include:</p> <p>Please include the following details in your report:</p> <ul> <li>Component: Which part of AgentVault is affected (library, registry, CLI, SDK)?</li> <li>Version: The specific version number or commit hash, if known.</li> <li>Description: A clear and concise description of the vulnerability.</li> <li>Steps to Reproduce: Detailed steps required to reproduce the vulnerability. Include code snippets, configuration details, or specific API requests if applicable.</li> <li>Potential Impact: Your assessment of the potential impact of the vulnerability.</li> <li>Contact Information: Your name or alias and contact email address for follow-up.</li> </ul>"},{"location":"security_policy/#our-commitment","title":"Our Commitment","text":"<ul> <li>We will acknowledge receipt of your vulnerability report, typically within 48 business hours.</li> <li>We will investigate the report promptly and work to validate the vulnerability.</li> <li>We will keep you informed of our progress during the investigation and remediation process.</li> <li>We aim to address critical vulnerabilities as quickly as possible.</li> <li>We will coordinate public disclosure with you after a fix is available, potentially issuing security advisories and crediting you for your discovery (unless you prefer to remain anonymous).</li> </ul>"},{"location":"security_policy/#safe-harbor","title":"Safe Harbor","text":"<p>We consider security research and vulnerability reporting activities conducted under this policy to be authorized and beneficial. We will not pursue legal action against individuals who report vulnerabilities in good faith, adhere to this policy, and do not cause harm to AgentVault, its users, or its infrastructure.</p> <p>Thank you for helping keep AgentVault secure.</p>"},{"location":"tee_profile/","title":"AgentVault TEE Profile (v0.1 - Declarative)","text":"<p>This document outlines the initial support for Trusted Execution Environments (TEEs) within the AgentVault ecosystem, focusing on declaration and discovery.</p> <p>Version: 0.1 (Declarative Phase)</p>"},{"location":"tee_profile/#overview","title":"Overview","text":"<p>Trusted Execution Environments (TEEs) like Intel SGX, AMD SEV, AWS Nitro Enclaves, Azure Confidential Computing, Confidential Space, etc., provide hardware-level isolation to protect the confidentiality and integrity of code and data being processed. Leveraging TEEs can significantly enhance the security posture of AI agents, especially when handling sensitive information or performing critical tasks.</p> <p>AgentVault aims to facilitate the use of TEEs by allowing agents to declare their TEE usage within their Agent Card and enabling clients (like the CLI or library) to discover agents based on this capability via the Registry.</p>"},{"location":"tee_profile/#agent-card-declaration","title":"Agent Card Declaration","text":"<p>Agents running within a TEE can declare this capability in their <code>agent-card.json</code> file within the <code>capabilities</code> object, using the optional <code>teeDetails</code> field. This corresponds to the <code>agentvault.models.TeeDetails</code> Pydantic model.</p> <p>Schema Fields:</p> <ul> <li><code>capabilities.teeDetails</code> (Optional Object): Contains details about the TEE. If this object is present, it indicates the agent utilizes a TEE.<ul> <li><code>type</code> (String, Required if <code>teeDetails</code> is present): An identifier for the specific TEE technology used. Examples: <code>\"Intel SGX\"</code>, <code>\"AMD SEV-SNP\"</code>, <code>\"AWS Nitro Enclaves\"</code>, <code>\"Azure Confidential Computing\"</code>, <code>\"Confidential Space\"</code>. Standardized identifiers are preferred, but custom strings are allowed.</li> <li><code>attestationEndpoint</code> (String, Optional, Format: URL): A URL where clients can potentially obtain or verify an attestation document for the specific TEE instance hosting the agent. The format and verification process for the attestation document are specific to the TEE type and are outside the scope of this profile version.</li> <li><code>publicKey</code> (String, Optional): A public key associated with the TEE instance, potentially used for establishing secure channels or verifying attestations. The format (e.g., PEM, JWK) depends on the TEE type and attestation protocol. Currently informational only.</li> <li><code>description</code> (String, Optional): A human-readable description of the TEE setup, its purpose, or the guarantees it provides for this agent.</li> </ul> </li> </ul> <p>Example <code>agent-card.json</code> Snippet:</p> <pre><code>{\n  \"schemaVersion\": \"1.0\",\n  // ... other fields ...\n  \"capabilities\": {\n    \"a2aVersion\": \"1.0\",\n    // ... other capabilities ...\n    \"teeDetails\": {\n      \"type\": \"AWS Nitro Enclaves\",\n      \"attestationEndpoint\": \"https://attestation.example-agent.com/verify\",\n      \"description\": \"Agent runs within an AWS Nitro Enclave for enhanced data confidentiality during processing.\"\n    }\n  },\n  // ... other fields ...\n}\n</code></pre>"},{"location":"tee_profile/#discovery-via-registry","title":"Discovery via Registry","text":"<p>The AgentVault Registry API (<code>agentvault_registry</code>) supports filtering agents based on their TEE declaration:</p> <ul> <li><code>GET /api/v1/agent-cards/?has_tee=true</code>: Returns only agents whose Agent Card includes the <code>capabilities.teeDetails</code> object (regardless of its content).</li> <li><code>GET /api/v1/agent-cards/?has_tee=false</code>: Returns only agents whose Agent Card does not include the <code>capabilities.teeDetails</code> object.</li> <li><code>GET /api/v1/agent-cards/?tee_type=&lt;type_string&gt;</code>: Returns only agents where <code>capabilities.teeDetails.type</code> matches the provided <code>&lt;type_string&gt;</code> (case-insensitive comparison recommended for the registry implementation). Example: <code>?tee_type=AWS%20Nitro%20Enclaves</code>.</li> </ul> <p>The public Registry Web UI and the <code>agentvault_cli discover</code> command also provide options corresponding to these filters.</p>"},{"location":"tee_profile/#current-scope-limitations-v01","title":"Current Scope &amp; Limitations (v0.1)","text":"<ul> <li>Declarative Only: This version focuses solely on allowing agents to declare their TEE usage and enabling discovery based on that declaration.</li> <li>No Automated Verification: AgentVault clients (library, CLI) do not automatically perform TEE attestation verification based on the <code>attestationEndpoint</code> or <code>publicKey</code>. Implementing robust and generic attestation verification is complex due to the variety of TEE technologies and attestation protocols.</li> <li>Client Responsibility: Clients wishing to verify an agent's TEE status must currently implement the verification logic themselves, specific to the declared <code>teeDetails.type</code> and using the provided <code>attestationEndpoint</code> or other out-of-band mechanisms. The presence of <code>teeDetails</code> in the card is not a guarantee verified by AgentVault itself.</li> <li>No Secure Channel Guarantee: Declaring TEE usage does not automatically establish a TEE-secured communication channel beyond standard transport security (HTTPS). Establishing such channels might be a future enhancement, potentially leveraging the <code>publicKey</code>.</li> </ul>"},{"location":"tee_profile/#future-work","title":"Future Work","text":"<ul> <li>Researching and potentially integrating standardized TEE attestation verification libraries or protocols into the <code>agentvault</code> client library.</li> <li>Defining mechanisms for establishing secure communication channels directly with TEE enclaves, possibly leveraging the declared <code>publicKey</code>.</li> <li>Standardizing <code>teeDetails.type</code> identifiers further.</li> </ul>"},{"location":"use_cases/","title":"AgentVault Use Cases &amp; Scenarios","text":"<p>The core AgentVault Vision is to enable a future where diverse AI agents can collaborate securely and effectively. This page provides more concrete examples of complex workflows made possible or significantly easier by the AgentVault ecosystem and its foundational components.</p> <p>These scenarios illustrate how features like standardized discovery (Registry), secure interoperable communication (A2A Profile), robust authentication (Auth Schemes &amp; KeyManager), and developer tooling (SDKs, Library) come together.</p>"},{"location":"use_cases/#scenario-1-hyper-personalized-concierge-automated-life-management","title":"Scenario 1: Hyper-Personalized Concierge &amp; Automated Life Management","text":"<p>The Goal: An AI personal assistant that proactively manages complex tasks like travel planning by securely coordinating multiple specialized agents based on deep user preferences.</p> <p>The Workflow:</p> <ol> <li>User Request: The user tells their primary Orchestrator Agent, \"Plan a relaxing weekend trip to Napa Valley next month for two people, budget under $1000. We want to visit 2-3 wineries known for excellent Cabernet Sauvignon, prefer boutique hotels with refundable rates, and need flights from SFO.\"</li> <li>Secure Context Retrieval: The Orchestrator Agent authenticates (e.g., using OAuth2) with the user's User Profile Agent. This agent runs in a TEE and securely stores sensitive preferences. It only releases relevant, scoped information.</li> <li>Dynamic Discovery (Registry): The Orchestrator queries the AgentVault Registry for agents with capabilities like <code>flights</code>, <code>hotels</code>, <code>wine-reviews</code>, <code>booking</code>.</li> <li>Parallel Task Delegation (A2A): The Orchestrator tasks the discovered agents (<code>FlightSearchAgent</code>, <code>WineReviewAgent</code>, <code>HotelSearchAgent</code>) via A2A.</li> <li>Asynchronous Results &amp; Streaming (A2A + SSE): Agents respond, potentially streaming results (like flight options) via SSE.</li> <li>Synthesis &amp; User Interaction: The Orchestrator correlates information and presents synthesized options to the user.</li> <li>Secure Action Execution (A2A + Auth): Upon user confirmation of an itinerary, the Orchestrator securely instructs the <code>HotelBookingAgent</code> (using its required auth scheme) to make the booking.</li> </ol> <p>Diagram:</p> <pre><code>graph TD\n    subgraph User Interaction\n        User -- Request --&gt; Orchestrator(Orchestrator Agent)\n        Orchestrator -- Presents Options/Confirms --&gt; User\n    end\n\n    subgraph Secure Profile\n        ProfileAgent[(User Profile Agent TEE)]\n        Orchestrator -- Auth &amp; Request Prefs --&gt; ProfileAgent\n        ProfileAgent -- Scoped Prefs --&gt; Orchestrator\n    end\n\n    subgraph Agent Discovery\n        Registry[(AgentVault Registry)]\n        Orchestrator -- Query Agents --&gt; Registry\n        Registry -- Agent Cards --&gt; Orchestrator\n    end\n\n    subgraph Task Execution\n        FlightAgent(Flight Search Agent)\n        HotelAgent(Hotel Search Agent)\n        ReviewAgent(Wine Review Agent)\n        BookingAgent(Hotel Booking Agent)\n\n        Orchestrator -- Task: Find Flights --&gt; FlightAgent\n        Orchestrator -- Task: Find Hotels --&gt; HotelAgent\n        Orchestrator -- Task: Find Reviews --&gt; ReviewAgent\n        FlightAgent -- Flight Options (SSE) --&gt; Orchestrator\n        HotelAgent -- Hotel Options --&gt; Orchestrator\n        ReviewAgent -- Winery List --&gt; Orchestrator\n        Orchestrator -- Task: Book Hotel --&gt; BookingAgent\n        BookingAgent -- Confirmation --&gt; Orchestrator\n    end\n\n    Registry -- Provides Agent URLs/Auth --&gt; Orchestrator</code></pre> <p>How AgentVault Enables This:</p> <ul> <li>Registry: Essential for discovering the specialized <code>FlightSearch</code>, <code>HotelSearch</code>, <code>WineReview</code>, and <code>Booking</code> agents dynamically.</li> <li>A2A Protocol: Provides the standard language for the Orchestrator to task diverse agents and receive structured results or streamed updates (SSE).</li> <li>Auth Schemes &amp; KeyManager: Enables secure, standardized authentication between the Orchestrator, the sensitive User Profile Agent, and the transactional Booking Agent.</li> <li>TEE Awareness: Allows the User Profile Agent to declare its secure TEE status, increasing trust.</li> <li>(Future) MCP: Would allow richer context to be passed securely.</li> </ul>"},{"location":"use_cases/#scenario-2-automated-scientific-discovery-pipeline","title":"Scenario 2: Automated Scientific Discovery Pipeline","text":"<p>The Goal: Accelerate research by automating the process of finding relevant studies, extracting key data, running complex simulations (potentially on secure hardware), analyzing results, and drafting reports.</p> <p>The Workflow:</p> <ol> <li>Setup: A researcher configures a Pipeline Orchestrator Agent.</li> <li>Literature Search (Discovery &amp; A2A): Orchestrator finds and tasks <code>PubMedSearchAgent</code> / <code>ArXivSearchAgent</code> via the Registry and A2A.</li> <li>Data Retrieval: Search agents return paper identifiers/URLs.</li> <li>Information Extraction (A2A &amp; Artifacts): Orchestrator tasks <code>PDFDataExtractionAgent</code> with URLs. Agent returns structured data Artifacts.</li> <li>Simulation Setup (TEE &amp; A2A): Orchestrator finds <code>ProteinFoldingSimAgent</code> (declaring TEE support) via Registry. (Future: Verifies attestation). Tasks agent via A2A with input data references.</li> <li>Secure Simulation: Simulation Agent runs computation in TEE, returns result Artifacts.</li> <li>Analysis (A2A): Orchestrator tasks <code>BioStatAnalysisAgent</code> with simulation results. Agent returns statistical summaries.</li> <li>Report Generation (A2A): Orchestrator sends components to <code>DraftWriterAgent</code>, receives draft manuscript section.</li> </ol> <p>Diagram:</p> <pre><code>graph TD\n    Researcher -- Configures --&gt; Orchestrator(Pipeline Orchestrator)\n    Registry[(AgentVault Registry)]\n\n    Orchestrator -- Find Agents --&gt; Registry\n\n    subgraph Literature Search\n        PubMed(PubMed Search Agent)\n        ArXiv(ArXiv Search Agent)\n        Orchestrator -- Search Keywords --&gt; PubMed\n        Orchestrator -- Search Keywords --&gt; ArXiv\n        PubMed -- Paper IDs/URLs --&gt; Orchestrator\n        ArXiv -- Paper IDs/URLs --&gt; Orchestrator\n    end\n\n    %% Ensure processing starts *after* search results return to Orchestrator\n    Orchestrator --&gt; DataProcessingStart(Start Data Processing)\n    DataProcessingStart -- URLs --&gt; Extractor(PDF Data Extractor)\n\n    subgraph Data Processing &amp; Analysis\n        Extractor -- Data Artifacts --&gt; Orchestrator\n        Orchestrator -- Input Data --&gt; Simulator[(Protein Sim Agent TEE)]\n        Simulator -- Result Artifacts --&gt; Orchestrator\n        Orchestrator -- Results --&gt; Analyzer(BioStat Analysis Agent)\n        Analyzer -- Analysis Summary --&gt; Orchestrator\n        Orchestrator -- All Components --&gt; Writer(Draft Writer Agent)\n        Writer -- Draft Section --&gt; Orchestrator\n    end\n\n    Orchestrator -- Final Report --&gt; Researcher\n\n    %% Link discovery to execution (implicit via Orchestrator)\n    Registry -- Provides Agent Info --&gt; Orchestrator</code></pre> <p>How AgentVault Enables This:</p> <ul> <li>Registry: Crucial for finding specialized scientific agents. Filtering by TEE support is key.</li> <li>A2A Protocol: Defines standard methods for tasking and retrieving complex results, including Artifacts.</li> <li>Artifacts: Provides a standard way to reference and exchange potentially large data files.</li> <li>TEE Declaration: Allows simulation agents to advertise their enhanced security posture.</li> <li>Modularity: Researchers can easily swap components found in the registry.</li> </ul>"},{"location":"use_cases/#scenario-3-decentralized-resilient-smart-factory-monitoring","title":"Scenario 3: Decentralized &amp; Resilient Smart Factory Monitoring","text":"<p>The Goal: Monitor and control factory floor equipment from various vendors in a resilient way, reducing reliance on a single central cloud and enabling faster local responses.</p> <p>The Workflow:</p> <ol> <li>Local Deployment &amp; Registration: Device Agents (on edge hardware) register with a local AgentVault Registry.</li> <li>Local Monitoring (Discovery &amp; SSE): A local Monitoring Agent discovers relevant Device Agents via the local Registry and subscribes to data streams using <code>tasks/sendSubscribe</code> (SSE).</li> <li>Anomaly Detection &amp; Alerting (A2A): Monitoring Agent detects an anomaly, finds an <code>AlertingAgent</code> via Registry, and sends an alert message via A2A.</li> <li>Automated Response (Discovery &amp; A2A + Auth): Alerting Agent notifies humans and tasks a <code>ControlAgent</code> (or specific Device Agent capability) via A2A using required Auth Scheme (e.g., <code>apiKey</code>) managed by <code>KeyManager</code>.</li> <li>Resilience: Local loops function even if external internet fails.</li> </ol> <p>Diagram:</p> <pre><code>graph TD\n    subgraph Factory Floor Devices\n        SensorAgent[Temp Sensor Agent]\n        ActuatorAgent[Valve Actuator Agent]\n        MachineAgent[Machine Status Agent]\n    end\n\n    subgraph Local Network Services\n        LocalRegistry[(Local AgentVault Registry)]\n        MonitorAgent(Monitoring Agent)\n        AlertAgent(Alerting Agent)\n        ControlAgent(Control Agent)\n        Supervisor(Human Supervisor)\n    end\n\n    %% Registration\n    SensorAgent -- Register --&gt; LocalRegistry\n    ActuatorAgent -- Register --&gt; LocalRegistry\n    MachineAgent -- Register --&gt; LocalRegistry\n    AlertAgent -- Register --&gt; LocalRegistry\n    ControlAgent -- Register --&gt; LocalRegistry\n\n    %% Monitoring Flow\n    MonitorAgent -- Discover Sensors --&gt; LocalRegistry\n    SensorAgent -- Temp Data (SSE) --&gt; MonitorAgent\n    MachineAgent -- Status Data (SSE) --&gt; MonitorAgent\n\n    %% Alerting &amp; Control Flow\n    MonitorAgent -- Anomaly Detected --&gt; AlertAgent\n    AlertAgent -- Notify --&gt; Supervisor\n    AlertAgent -- Discover Control --&gt; LocalRegistry\n    AlertAgent -- Trigger Action --&gt; ControlAgent\n    ControlAgent -- Discover Actuator --&gt; LocalRegistry\n    ControlAgent -- Send Command (Auth) --&gt; ActuatorAgent\n</code></pre> <p>How AgentVault Enables This:</p> <ul> <li>Local Registry: Enables discovery and coordination within a private network.</li> <li>Standardized A2A: Allows heterogeneous devices (wrapped as agents) to communicate.</li> <li>SSE Streaming: Enables efficient real-time monitoring.</li> <li>Auth Schemes &amp; KeyManager: Secures control commands locally.</li> <li>Decentralization: Facilitates a more resilient architecture.</li> </ul> <p>These scenarios illustrate how AgentVault's focus on discovery, standardized communication, security, and developer tooling provides the necessary foundation for building sophisticated, collaborative multi-agent systems in diverse domains.</p>"},{"location":"vision/","title":"The AgentVault Vision: Enabling the Collaborative AI Future","text":""},{"location":"vision/#the-fragmented-present-islands-of-intelligence","title":"The Fragmented Present: Islands of Intelligence","text":"<p>The era of Artificial Intelligence is rapidly evolving. We see powerful, specialized AI agents emerging daily, capable of remarkable feats in language, analysis, planning, and execution. Yet, despite their individual brilliance, these agents largely exist as isolated islands of intelligence.</p> <p>Integrating them into complex workflows often requires bespoke, brittle connections. Communicating context and ensuring security between agents from different providers or built with different tools is a significant challenge. Key problems hinder the realization of truly collaborative AI:</p> <ul> <li>Discovery: How can agents dynamically find other agents with the specific capabilities they need?</li> <li>Interoperability: How can agents built by different teams, using different models or platforms, communicate reliably and understand each other?</li> <li>Security &amp; Trust: How can we ensure that interactions between agents are secure, that credentials aren't exposed, and that agents operate within expected boundaries, potentially within verifiable Trusted Execution Environments (TEEs)?</li> <li>Context Management: How can agents efficiently share the necessary context (user goals, history, data references) to perform collaborative tasks without exceeding limitations or losing vital information?</li> <li>Developer Experience: How can we make it easier for developers to build agents that can collaborate, without getting bogged down in complex protocol implementations and security hurdles?</li> </ul> <p>Without addressing these foundational issues, the true potential of multi-agent systems \u2013 where specialized AIs work together to solve problems beyond the scope of any single agent \u2013 remains largely untapped.</p>"},{"location":"vision/#the-agentvault-solution-a-foundation-for-collaboration","title":"The AgentVault Solution: A Foundation for Collaboration","text":"<p>AgentVault is an open-source ecosystem designed to be the bedrock for this collaborative future. We are building the essential infrastructure and standards to tear down the silos and connect the islands of intelligence.</p> <p>AgentVault provides a cohesive set of tools and specifications addressing the core challenges:</p> <ol> <li>Discovery (<code>agentvault_registry</code>): A central, queryable registry where developers can publish standardized \"Agent Cards\". This allows clients (users or other agents) to easily find agents based on name, description, capabilities, tags, TEE support, and other metadata.</li> <li>Standardized Communication (<code>A2A Profile</code>): A defined Agent-to-Agent (A2A) communication protocol based on JSON-RPC 2.0 and Server-Sent Events (SSE). This ensures that agents, regardless of their underlying implementation, can reliably exchange messages, manage task lifecycles (initiate, get status, cancel), and receive real-time updates using a common language.</li> <li>Secure Interaction (<code>KeyManager</code>, Auth Schemes): Robust mechanisms for authenticating agents using various schemes (API Keys, OAuth2 Client Credentials) coupled with secure local credential management (<code>KeyManager</code>) on the client-side and best practices (hashed keys, HTTPS enforcement) throughout the ecosystem.</li> <li>Developer Enablement (<code>SDK</code>, <code>Library</code>, <code>CLI</code>): Practical tools to simplify the process:<ul> <li><code>agentvault-server-sdk</code>: Makes building A2A-compliant agents easier, handling protocol boilerplate and integrating with frameworks like FastAPI.</li> <li><code>agentvault</code> (Library): Provides a Python client for programmatically interacting with agents and the registry.</li> <li><code>agentvault-cli</code>: Offers a user-friendly command-line interface for discovery, interaction, and credential management.</li> </ul> </li> </ol> <p>By focusing on open standards, security, and developer experience, AgentVault aims to provide the essential, non-proprietary plumbing for the multi-agent world.</p>"},{"location":"vision/#the-vision-an-interconnected-ai-ecosystem","title":"The Vision: An Interconnected AI Ecosystem","text":"<p>We envision a future powered by AgentVault where seamless, secure collaboration between diverse AI agents unlocks unprecedented capabilities. This foundation enables complex workflows previously difficult or impossible to achieve:</p> <ul> <li>Imagine hyper-personalized assistants securely coordinating specialized travel, scheduling, and profile agents to manage your life proactively.</li> <li>Picture automated scientific discovery pipelines where research agents seamlessly link literature review, data extraction, secure simulation (potentially in TEEs), and analysis agents.</li> <li>Envisage resilient smart factories where local device agents communicate directly for monitoring and control, reducing reliance on single cloud platforms.</li> </ul> <p>These are just glimpses of the potential. By providing the common rails for discovery, communication, and security, AgentVault fosters an environment where specialized agents can be combined like building blocks, leading to emergent solutions and accelerating innovation across domains.</p> <p>\u27a1\ufe0f See Detailed Use Cases &amp; Scenarios to explore these possibilities in more depth.</p>"},{"location":"vision/#core-principles","title":"Core Principles","text":"<p>Our vision is guided by these fundamental principles:</p> <ul> <li>Open Source: All core components and specifications are developed under the permissive Apache 2.0 license, ensuring transparency, community involvement, and freedom from vendor lock-in.</li> <li>Security-First: Security is not an afterthought. From secure credential management and mandatory HTTPS (for non-localhost) to TEE awareness and robust authentication handling, building a trustworthy ecosystem is paramount.</li> <li>Interoperability: Adherence to open standards (JSON-RPC, SSE, emerging A2A concepts) and well-defined schemas (<code>AgentCard</code>) ensures that agents built by different teams using different technologies can communicate effectively.</li> <li>Decentralization: While the registry provides discovery, agent execution remains decentralized. AgentVault does not dictate where or how agents are hosted, promoting flexibility and resilience.</li> <li>Developer Focus: Providing practical SDKs, libraries, clear documentation, and examples lowers the barrier for developers to build and integrate A2A-compliant agents.</li> </ul>"},{"location":"vision/#why-agentvault","title":"Why AgentVault?","text":"<p>AgentVault differentiates itself by providing a holistic, secure, and open foundation specifically designed for the challenges of A2A interaction. We combine:</p> <ul> <li>Standardized Discovery: A dedicated registry with a defined schema.</li> <li>Secure Communication: A clear A2A protocol profile with built-in support for standard authentication methods.</li> <li>Practical Tooling: SDKs, libraries, and CLI tools designed to work together seamlessly.</li> <li>Security Emphasis: Integrated secure key management and TEE awareness from the outset.</li> </ul>"},{"location":"vision/#join-the-vision","title":"Join the Vision","text":"<p>Building the future of collaborative AI requires a community effort. Whether you are developing agents, building applications that use agents, or are interested in the underlying protocols and security, we invite you to:</p> <ul> <li>Use AgentVault: Build your agents using the Server SDK, interact with agents using the Client Library and CLI.</li> <li>Register Your Agents: Make your agents discoverable by submitting them to the public registry (or run your own!).</li> <li>Contribute: Help improve the code, documentation, and examples. Report issues, suggest features, and submit pull requests. See our Contributing Guide.</li> <li>Engage: Join the discussions on our GitHub Repository.</li> </ul> <p>Let's build the interconnected AI ecosystem, together.</p>"},{"location":"developer_guide/library/","title":"Developer Guide: Client Library (<code>agentvault</code>)","text":"<p>The <code>agentvault</code> library is the core Python package for interacting with the AgentVault ecosystem from the client-side. It enables applications, scripts, or even other agents to discover A2A agents, manage credentials securely, and communicate using the A2A protocol.</p>"},{"location":"developer_guide/library/#installation","title":"Installation","text":"<p>Install the library from PyPI:</p> <pre><code>pip install agentvault\n</code></pre> <p>For optional OS Keyring support (recommended for secure credential storage):</p> <pre><code>pip install \"agentvault[os_keyring]\"\n</code></pre> <p>See the main Installation Guide for more details, including setting up a development environment.</p>"},{"location":"developer_guide/library/#key-components","title":"Key Components","text":""},{"location":"developer_guide/library/#keymanager-key_managerpy","title":"<code>KeyManager</code> (<code>key_manager.py</code>)","text":"<p>Handles secure loading, storage, and retrieval of credentials (API keys, OAuth 2.0 Client ID/Secret) needed for agent authentication.</p> <ul> <li>Purpose: Abstracts credential sources so your client code doesn't need to handle each case explicitly. Provides a consistent interface (<code>get_key</code>, <code>get_oauth_client_id</code>, etc.) regardless of where the credential is stored.</li> <li>Initialization: <pre><code>from agentvault import KeyManager\nimport pathlib\n\n# Recommended: Load from environment variables AND OS keyring (if available)\n# Keyring is checked only if the key isn't found in env vars first.\nkm_env_keyring = KeyManager(use_keyring=True)\n\n# Load ONLY from a specific .env file (disable env vars and keyring)\n# key_file_path = pathlib.Path(\"path/to/your/keys.env\")\n# km_file_only = KeyManager(key_file_path=key_file_path, use_env_vars=False, use_keyring=False)\n\n# Load from file AND environment (file takes priority over env)\n# key_file_path = pathlib.Path(\"path/to/your/keys.json\")\n# km_file_env = KeyManager(key_file_path=key_file_path, use_env_vars=True, use_keyring=False)\n</code></pre></li> <li>Priority Order: When retrieving credentials, <code>KeyManager</code> checks sources in this order:<ol> <li>File Cache: If <code>key_file_path</code> was provided during init and the file contained the credential.</li> <li>Environment Variable Cache: If <code>use_env_vars=True</code> (default) and the corresponding environment variable was set during init.</li> <li>OS Keyring: If <code>use_keyring=True</code> and the credential was not found in the file or environment caches. This check happens on demand when a <code>get_...</code> method is called.</li> </ol> </li> <li>Service Identifier (<code>service_id</code>): This is the crucial string used to look up credentials. It's a local name you choose (e.g., \"openai\", \"my-agent-key\", \"google-oauth-agent\") that maps to the credentials needed for a specific agent or service.<ul> <li>It often corresponds to the <code>authSchemes[].service_identifier</code> field in an Agent Card.</li> <li>If the Agent Card omits <code>service_identifier</code>, the client might default to using the agent's <code>humanReadableId</code> or require the user/developer to specify which local <code>service_id</code> to use (e.g., via <code>agentvault_cli run --key-service &lt;your_local_id&gt;</code>).</li> </ul> </li> <li>Storage Conventions:<ul> <li>Environment Variables:<ul> <li>API Key: <code>AGENTVAULT_KEY_&lt;SERVICE_ID_UPPER&gt;</code></li> <li>OAuth Client ID: <code>AGENTVAULT_OAUTH_&lt;SERVICE_ID_UPPER&gt;_CLIENT_ID</code></li> <li>OAuth Client Secret: <code>AGENTVAULT_OAUTH_&lt;SERVICE_ID_UPPER&gt;_CLIENT_SECRET</code></li> </ul> </li> <li><code>.env</code> File:<ul> <li>API Key: <code>&lt;service_id_lower&gt;=your_api_key</code></li> <li>OAuth Client ID: <code>AGENTVAULT_OAUTH_&lt;service_id_lower&gt;_CLIENT_ID=your_client_id</code></li> <li>OAuth Client Secret: <code>AGENTVAULT_OAUTH_&lt;service_id_lower&gt;_CLIENT_SECRET=your_client_secret</code></li> </ul> </li> <li><code>.json</code> File: <pre><code>{\n  \"service_id_lower\": \"your_api_key\",\n  \"another_service\": {\n    \"apiKey\": \"another_api_key\",\n    \"oauth\": {\n      \"clientId\": \"oauth_client_id\",\n      \"clientSecret\": \"oauth_client_secret\"\n    }\n  }\n}\n</code></pre></li> <li>OS Keyring: Uses specific service/username conventions (see <code>key_manager.py</code> source for details, e.g., service=<code>agentvault:oauth:&lt;norm_id&gt;</code>, username=<code>clientId</code>). Use <code>agentvault_cli config set &lt;service_id&gt; --keyring</code> or <code>--oauth-configure</code> to store securely.</li> </ul> </li> <li>Retrieving Credentials: <pre><code>km = KeyManager(use_keyring=True) # Example instance\n\n# Get API Key (returns None if not found)\napi_key = km.get_key(\"openai\")\nif api_key:\n    source = km.get_key_source(\"openai\") # 'env', 'file', 'keyring', or None\n    print(f\"Found OpenAI API Key (Source: {source})\")\n\n# Get OAuth Credentials (return None if not found or incomplete)\nclient_id = km.get_oauth_client_id(\"google-oauth-agent\")\nclient_secret = km.get_oauth_client_secret(\"google-oauth-agent\")\nif client_id and client_secret:\n    status = km.get_oauth_config_status(\"google-oauth-agent\")\n    print(f\"Found Google OAuth Credentials ({status})\")\n    print(f\"  Client ID: {client_id}\")\n    # Note: AgentVaultClient uses these to automatically fetch the Bearer token.\n</code></pre></li> <li>Storing Credentials (Primarily for CLI/Setup): <pre><code>from agentvault import KeyManagementError\n\nkm = KeyManager(use_keyring=True)\ntry:\n    # Store API Key securely in OS keyring\n    km.set_key_in_keyring(\"my-new-service\", \"sk-abc...\")\n    print(\"API Key stored successfully.\")\n\n    # Store OAuth creds securely in OS keyring\n    km.set_oauth_creds_in_keyring(\"my-oauth-service\", \"client_id_123\", \"client_secret_xyz\")\n    print(\"OAuth credentials stored successfully.\")\n\nexcept KeyManagementError as e:\n    # Handle cases where keyring is unavailable or write fails\n    print(f\"Failed to store credentials in keyring: {e}\")\nexcept ValueError as e:\n    print(f\"Invalid input for storing credentials: {e}\")\n</code></pre></li> </ul>"},{"location":"developer_guide/library/#agentvaultclient-clientpy","title":"<code>AgentVaultClient</code> (<code>client.py</code>)","text":"<p>The primary class for making asynchronous A2A calls to remote agents.</p> <ul> <li>Purpose: Handles HTTP requests (using <code>httpx</code>), authentication logic (including OAuth2 Client Credentials token fetching/caching), JSON-RPC formatting, SSE streaming, and response parsing according to the A2A Profile v0.2.</li> <li> <p>Usage: Best used as an async context manager (<code>async with</code>) to ensure the underlying HTTP client is properly closed. Requires an <code>AgentCard</code> instance (loaded via <code>agent_card_utils</code>) and a <code>KeyManager</code> instance for authentication.</p> <pre><code>import asyncio\nimport logging\nimport pathlib\nfrom agentvault import (\n    AgentVaultClient, KeyManager, Message, TextPart,\n    agent_card_utils, exceptions as av_exceptions, models as av_models\n)\n\n# Configure logging for visibility\nlogging.basicConfig(level=logging.INFO)\n\nasync def run_agent_task(agent_ref: str, input_text: str):\n    # Initialize KeyManager - typically done once per application\n    key_manager = KeyManager(use_keyring=True)\n    agent_card = None\n    task_id = None\n\n    try:\n        # --- 1. Load Agent Card ---\n        print(f\"Loading agent card: {agent_ref}\")\n        # (Simplified loading logic - see previous version for URL/File/ID handling)\n        agent_card = await agent_card_utils.fetch_agent_card_from_url(agent_ref) # Example URL load\n\n        if not agent_card:\n             print(f\"Error: Could not load agent card for {agent_ref}\")\n             return\n        print(f\"Loaded Agent: {agent_card.name}\")\n\n        # --- 2. Prepare Initial Message ---\n        initial_message = Message(role=\"user\", parts=[TextPart(content=input_text)])\n        mcp_data = {\"user_preference\": \"verbose\"} # Optional MCP context\n\n        # --- 3. Interact using AgentVaultClient ---\n        async with AgentVaultClient() as client:\n            # Initiate the task\n            # AgentVaultClient automatically handles authentication (apiKey or oauth2)\n            # based on agent_card.authSchemes and credentials from key_manager.\n            print(f\"Initiating task...\")\n            task_id = await client.initiate_task(\n                agent_card=agent_card,\n                initial_message=initial_message,\n                key_manager=key_manager,\n                mcp_context=mcp_data,\n            )\n            print(f\"Task initiated: {task_id}\")\n\n            # Stream and process events\n            print(\"Streaming events...\")\n            final_response_text = \"\"\n            async for event in client.receive_messages(\n                agent_card=agent_card, task_id=task_id, key_manager=key_manager\n            ):\n                if isinstance(event, av_models.TaskStatusUpdateEvent):\n                    print(f\"  Status Update: {event.state} \"\n                          f\"(Msg: {event.message or 'N/A'})\")\n                    if event.state in [av_models.TaskState.COMPLETED,\n                                       av_models.TaskState.FAILED,\n                                       av_models.TaskState.CANCELED]:\n                        print(\"  Terminal state reached.\")\n                        break\n                elif isinstance(event, av_models.TaskMessageEvent):\n                    print(f\"  Message Received (Role: {event.message.role}):\")\n                    for part in event.message.parts:\n                        if isinstance(part, TextPart):\n                            print(f\"    Text: {part.content}\")\n                            if event.message.role == \"assistant\":\n                                final_response_text += part.content + \"\\n\"\n                        # --- ADDED: Example handling other part types ---\n                        elif isinstance(part, av_models.FilePart):\n                            print(f\"    File Ref: {part.url} (Type: {part.media_type}, Name: {part.filename})\")\n                        elif isinstance(part, av_models.DataPart):\n                            print(f\"    Data (Type: {part.media_type}): {part.content}\")\n                        # --- END ADDED ---\n                        else:\n                            print(f\"    Part (Type: {getattr(part, 'type', 'Unknown')}): {part}\")\n                elif isinstance(event, av_models.TaskArtifactUpdateEvent):\n                     artifact = event.artifact\n                     print(f\"  Artifact Update (ID: {artifact.id}, Type: {artifact.type}):\")\n                     if artifact.url: print(f\"    URL: {artifact.url}\")\n                     if artifact.media_type: print(f\"    Media Type: {artifact.media_type}\")\n                     # Handle content display/saving based on size/type\n                     if artifact.content:\n                         content_repr = repr(artifact.content)\n                         print(f\"    Content: {content_repr[:100]}{'...' if len(content_repr) &gt; 100 else ''}\")\n                     else:\n                         print(\"    Content: [Not provided directly]\")\n                # --- ADDED: Handling potential error events within stream ---\n                # Note: A2ARemoteAgentError might also be raised by receive_messages\n                # if the stream itself returns an error status initially.\n                elif isinstance(event, dict) and event.get(\"error\"): # Check for error structure\n                     print(f\"  ERROR received via SSE stream: {event}\")\n                     # Decide how to handle stream errors (e.g., break, log, append to response)\n                     final_response_text += f\"\\n[Stream Error: {event.get('message', 'Unknown')}]\"\n                     break # Example: Stop processing on stream error\n                # --- END ADDED ---\n                else:\n                    print(f\"  Received unknown event type: {type(event)}\")\n\n            print(\"\\n--- Final Aggregated Agent Response ---\")\n            print(final_response_text.strip())\n            print(\"---------------------------------------\")\n\n    # --- 5. Handle Potential Errors ---\n    except av_exceptions.AgentCardError as e:\n        print(f\"Error loading or validating agent card: {e}\")\n    except av_exceptions.A2AAuthenticationError as e:\n        print(f\"Authentication error: {e}\")\n        print(\"Hint: Ensure credentials for the required service_id are configured.\")\n    except av_exceptions.A2AConnectionError as e:\n        print(f\"Connection error communicating with agent or token endpoint: {e}\")\n    except av_exceptions.A2ARemoteAgentError as e:\n        # Agent returned an error (e.g., JSON-RPC error or non-2xx HTTP status)\n        print(f\"Agent returned an error:\")\n        print(f\"  Status Code (if HTTP/RPC error): {e.status_code}\") # Can be HTTP status or RPC code\n        print(f\"  Message: {e}\")\n        print(f\"  Response Body/Data: {e.response_body}\") # Contains JSON RPC error data or HTTP body\n    except av_exceptions.A2AMessageError as e:\n         print(f\"A2A protocol message error (e.g., invalid format): {e}\")\n    except av_exceptions.A2ATimeoutError as e:\n         print(f\"A2A request timed out: {e}\")\n    except av_exceptions.KeyManagementError as e:\n         print(f\"Error managing local keys/credentials: {e}\")\n    except NotImplementedError as e:\n         print(f\"Functionality not implemented: {e}\")\n    except Exception as e:\n        print(f\"An unexpected error occurred: {type(e).__name__}: {e}\")\n        logging.exception(\"Unexpected error details:\")\n\n# Example usage:\n# asyncio.run(run_agent_task(\"https://some-agent.com/agent-card.json\", \"Summarize this document.\"))\n</code></pre> </li> </ul>"},{"location":"developer_guide/library/#models-agentvaultmodels","title":"Models (<code>agentvault.models</code>)","text":"<p>Pydantic models defining the data structures for Agent Cards and the A2A protocol. Refer to the source code docstrings or the A2A Profile v0.2 for details on specific models like <code>AgentCard</code>, <code>Message</code>, <code>Task</code>, <code>TaskState</code>, <code>A2AEvent</code>, etc.</p>"},{"location":"developer_guide/library/#exceptions-agentvaultexceptions","title":"Exceptions (<code>agentvault.exceptions</code>)","text":"<p>Custom exceptions provide granular error handling. Catching these allows for more robust client applications.</p> <ul> <li><code>AgentCardError</code>: Issues loading/validating the Agent Card.</li> <li><code>A2AAuthenticationError</code>: Missing/invalid credentials, OAuth flow failures. Check KeyManager setup.</li> <li><code>A2AConnectionError</code>: Network issues connecting to the agent or token endpoint (DNS, connection refused).</li> <li><code>A2ATimeoutError</code>: Request timed out.</li> <li><code>A2ARemoteAgentError</code>: The agent returned an error. Check <code>e.status_code</code> (can be HTTP status or JSON-RPC error code) and <code>e.response_body</code> (can be HTTP response text or JSON-RPC error data) for details from the agent.</li> <li><code>A2AMessageError</code>: Invalid JSON-RPC format or unexpected response structure from the agent.</li> <li><code>KeyManagementError</code>: Issues saving/loading keys with <code>KeyManager</code>.</li> </ul> <p>See the example above for a basic <code>try...except</code> block structure.</p>"},{"location":"developer_guide/library/#utilities-agentvaultagent_card_utils-agentvaultmcp_utils","title":"Utilities (<code>agentvault.agent_card_utils</code>, <code>agentvault.mcp_utils</code>)","text":"<ul> <li><code>agent_card_utils</code>: Functions like <code>load_agent_card_from_file</code> and <code>fetch_agent_card_from_url</code> simplify obtaining and validating <code>AgentCard</code> objects.</li> <li><code>mcp_utils</code>: Contains helpers for handling Model Context Protocol data.<ul> <li><code>format_mcp_context</code>: (Primarily for advanced clients or server-side) Validates and formats a dictionary intended as MCP context.</li> <li><code>get_mcp_context</code>: (Client-side) Safely extracts the <code>mcp_context</code> dictionary from a received <code>Message</code>'s metadata.</li> </ul> </li> </ul>"},{"location":"developer_guide/registry/","title":"Developer Guide: Registry API (<code>agentvault_registry</code>)","text":"<p>The AgentVault Registry provides a central RESTful API service for discovering and managing Agent Cards. Developers interact with it programmatically to publish their agents, while clients (like the <code>agentvault_cli</code> or other applications) use it to find agents.</p> <p>(Note: Alongside the API, the <code>agentvault_registry</code> service also hosts a basic Web UI for public discovery at <code>/ui</code> and a developer portal at <code>/ui/developer</code> on the same host where the API is deployed.)</p>"},{"location":"developer_guide/registry/#api-base-path-public-instance","title":"API Base Path &amp; Public Instance","text":"<ul> <li>Base Path: All registry API endpoints are prefixed with <code>/api/v1</code>.</li> <li>Public Instance: A live instance is available at: <code>https://agentvault-registry-api.onrender.com</code><ul> <li>API Endpoint Example: <code>https://agentvault-registry-api.onrender.com/api/v1/agent-cards/</code></li> </ul> </li> <li>Public Instance Note (Cold Start): This instance runs on Render's free tier. If inactive, it may take up to 60 seconds to respond to the first request. Subsequent requests will be faster. Consider sending a simple request (e.g., <code>GET /health</code>) to wake it up before making critical calls if latency is a concern.</li> <li>Local Development: When running locally (see Installation Guide), the base URL is typically <code>http://localhost:8000/api/v1</code>.</li> </ul>"},{"location":"developer_guide/registry/#authentication-developer-registration","title":"Authentication &amp; Developer Registration","text":"<ul> <li>Developer Authentication: Endpoints related to managing agent cards (creating, updating, deleting) require developer authentication. This is handled via an API key specific to the developer, provided in the <code>X-Api-Key</code> HTTP header.</li> <li>Obtaining an API Key (Current Process): Currently, there is no self-service registration. To obtain a Developer API Key for submitting agents to the public registry, please contact the AgentVault project maintainers at: <code>[CONTACT_EMAIL_PLACEHOLDER]</code> (Note: Replace placeholder before production). Include your desired developer name. A key will be generated and securely provided to you. (Self-service registration is planned for a future release - see Roadmap).</li> <li>Public Access: Endpoints for discovering agents (listing/searching, getting details by ID, validating cards) generally do not require authentication.</li> <li>Exception: The <code>GET /agent-cards/</code> endpoint requires authentication only if the <code>owned_only=true</code> query parameter is used.</li> </ul>"},{"location":"developer_guide/registry/#common-error-responses","title":"Common Error Responses","text":"<p>The API uses standard HTTP status codes. Common errors include:</p> <ul> <li><code>401 Unauthorized</code>: Returned if a required <code>X-Api-Key</code> header is missing or invalid for a protected endpoint, or if the key is invalid when using <code>owned_only=true</code>.</li> <li><code>403 Forbidden</code>: Returned if a valid <code>X-Api-Key</code> was provided, but the authenticated developer does not have permission for the requested action (e.g., attempting to modify or delete another developer's Agent Card).</li> <li><code>404 Not Found</code>: Returned if the requested resource (e.g., an Agent Card with a specific UUID) does not exist.</li> <li><code>422 Unprocessable Entity</code>: Returned if the request body (e.g., for <code>POST</code> or <code>PUT</code>) fails validation. This commonly occurs if the submitted <code>card_data</code> does not conform to the Agent Card schema defined in the <code>agentvault</code> library, or if other required fields in the request schema are missing/invalid. The response <code>detail</code> field usually contains specific information about the validation errors from Pydantic.</li> <li><code>500 Internal Server Error</code>: Returned for unexpected errors on the server (e.g., database connection issue, unhandled exception in the API logic). Check server logs for details.</li> <li><code>503 Service Unavailable</code>: May be returned by the hosting platform (like Render) if the service is experiencing issues or during a cold start if the request times out before the service is fully awake.</li> </ul>"},{"location":"developer_guide/registry/#api-endpoints","title":"API Endpoints","text":""},{"location":"developer_guide/registry/#agent-cards-agent-cards","title":"Agent Cards (<code>/agent-cards</code>)","text":""},{"location":"developer_guide/registry/#post","title":"<code>POST /</code>","text":"<ul> <li>Summary: Submit a new Agent Card.</li> <li>Description: Submits a new Agent Card associated with the authenticated developer. The provided <code>card_data</code> is validated against the canonical <code>agentvault.models.AgentCard</code> schema. The server automatically extracts the <code>name</code> and <code>description</code> fields from the validated <code>card_data</code> for indexing and faster retrieval in list views.</li> <li>Authentication: Required (<code>X-Api-Key</code>).</li> <li>Request Body: <code>schemas.AgentCardCreate</code> <pre><code>{\n  \"card_data\": {\n    \"schemaVersion\": \"1.0\",\n    \"humanReadableId\": \"your-org/your-agent\",\n    \"agentVersion\": \"1.1.0\",\n    \"name\": \"My Awesome Agent\", // Required within card_data\n    \"description\": \"This agent does amazing things.\", // Required within card_data\n    \"url\": \"https://my-agent.example.com/a2a\",\n    \"provider\": { \"name\": \"My Org\" },\n    \"capabilities\": { \"a2aVersion\": \"1.0\" },\n    \"authSchemes\": [ { \"scheme\": \"apiKey\", \"service_identifier\": \"my-agent-service\" } ]\n    // ... other valid Agent Card fields ...\n  }\n}\n</code></pre></li> <li>Success Response (201 Created): <code>schemas.AgentCardRead</code> - Returns the full details of the newly created card record, including its generated UUID (<code>id</code>), timestamps, and the <code>developer_is_verified</code> status which reflects the verification status of the developer who submitted the card.     <pre><code>{\n  \"id\": \"a1b2c3d4-e5f6-7890-1234-567890abcdef\",\n  \"developer_id\": 15,\n  \"developer_is_verified\": false, // Reflects status of developer ID 15\n  \"card_data\": { /* ... submitted card_data ... */ },\n  \"name\": \"My Awesome Agent\", // Extracted from card_data\n  \"description\": \"This agent does amazing things.\", // Extracted from card_data\n  \"is_active\": true,\n  \"created_at\": \"2024-04-15T12:00:00Z\",\n  \"updated_at\": \"2024-04-15T12:00:00Z\"\n}\n</code></pre></li> <li>Errors: 401, 403, 422 (e.g., invalid <code>card_data</code>, missing required fields like <code>name</code> or <code>description</code> within <code>card_data</code>), 500.</li> </ul>"},{"location":"developer_guide/registry/#get","title":"<code>GET /</code>","text":"<ul> <li>Summary: List Agent Cards.</li> <li>Description: Retrieves a paginated list of Agent Cards, with options for filtering. By default, only active cards (<code>is_active=true</code>) are returned. Results are summaries (<code>schemas.AgentCardSummary</code>).</li> <li>Authentication: Optional. Required only if <code>owned_only=true</code>.</li> <li>Query Parameters:<ul> <li><code>skip</code> (int, default: 0, min: 0): Offset for pagination.</li> <li><code>limit</code> (int, default: 100, min: 1, max: 250): Max items per page.</li> <li><code>active_only</code> (bool, default: true): Set to <code>false</code> to include inactive cards.</li> <li><code>search</code> (str, optional, max_length: 100): Case-insensitive search term applied to indexed <code>name</code> and <code>description</code> fields.</li> <li><code>tags</code> (list[str], optional): Filter by tags present in <code>card_data.tags</code>. Provide the parameter multiple times for AND logic (e.g., <code>?tags=weather&amp;tags=forecast</code>). Requires agents to have all specified tags (uses JSONB containment <code>@&gt;</code> query).</li> <li><code>has_tee</code> (bool, optional): Filter by TEE support declaration (<code>card_data.capabilities.teeDetails</code> existence).</li> <li><code>tee_type</code> (str, optional, max_length: 50): Filter by specific TEE type string (<code>card_data.capabilities.teeDetails.type</code>). Case-insensitive match.</li> <li><code>owned_only</code> (bool, default: false): If <code>true</code>, requires <code>X-Api-Key</code> header and returns only cards owned by the authenticated developer.</li> </ul> </li> <li>Success Response (200 OK): <code>schemas.AgentCardListResponse</code> <pre><code>{\n  \"items\": [\n    {\n      \"id\": \"a1b2c3d4-e5f6-7890-1234-567890abcdef\",\n      \"name\": \"My Awesome Agent\",\n      \"description\": \"This agent does amazing things.\"\n    },\n    // ... other AgentCardSummary objects ...\n  ],\n  \"pagination\": {\n    \"total_items\": 150,\n    \"limit\": 100,\n    \"offset\": 0,\n    \"total_pages\": 2,\n    \"current_page\": 1\n  }\n}\n</code></pre></li> <li>Errors: 401 (if <code>owned_only=true</code> and auth fails), 500, 503 (potentially during cold start).</li> </ul>"},{"location":"developer_guide/registry/#get-card_id","title":"<code>GET /{card_id}</code>","text":"<ul> <li>Summary: Get Agent Card by ID.</li> <li>Description: Retrieves the full details of a specific Agent Card by its UUID. Includes the <code>developer_is_verified</code> status of the owning developer.</li> <li>Authentication: Public.</li> <li>Path Parameter:<ul> <li><code>card_id</code> (UUID): The unique ID of the agent card (e.g., <code>a1b2c3d4-e5f6-7890-1234-567890abcdef</code>).</li> </ul> </li> <li>Success Response (200 OK): <code>schemas.AgentCardRead</code> (Similar structure to the <code>POST /</code> success response).</li> <li>Errors: 404 (if ID not found), 500, 503 (potentially during cold start).</li> </ul>"},{"location":"developer_guide/registry/#put-card_id","title":"<code>PUT /{card_id}</code>","text":"<ul> <li>Summary: Update an Agent Card.</li> <li>Description: Updates an existing Agent Card. Only the authenticated owner of the card can perform this action. Fields not included in the request body (<code>card_data</code>, <code>is_active</code>) are left unchanged. If <code>card_data</code> is provided, it replaces the existing <code>card_data</code> entirely after validation, and the indexed <code>name</code>/<code>description</code> fields in the database are updated accordingly.</li> <li>Authentication: Required (<code>X-Api-Key</code>, must match card owner).</li> <li>Path Parameter:<ul> <li><code>card_id</code> (UUID): The ID of the agent card to update.</li> </ul> </li> <li>Request Body: <code>schemas.AgentCardUpdate</code> <pre><code>{\n  // Example: Update only card_data (must be complete and valid)\n  \"card_data\": {\n     \"schemaVersion\": \"1.0\",\n     \"humanReadableId\": \"your-org/your-agent\", // Usually shouldn't change ID\n     \"agentVersion\": \"1.2.0\", // Updated version\n     \"name\": \"My Updated Agent\", // Updated name\n     \"description\": \"Now with more features!\", // Updated description\n     \"url\": \"https://my-agent.example.com/a2a/v2\", // Updated URL\n     \"provider\": { \"name\": \"My Org\" },\n     \"capabilities\": { \"a2aVersion\": \"1.0\" },\n     \"authSchemes\": [ { \"scheme\": \"apiKey\", \"service_identifier\": \"my-agent-service\" } ]\n  }\n}\n</code></pre> <pre><code>{\n  // Example: Update only active status\n  \"is_active\": false\n}\n</code></pre></li> <li>Success Response (200 OK): <code>schemas.AgentCardRead</code> - Returns the full details of the updated card record.</li> <li>Errors: 401, 403 (if not owner), 404, 422 (if <code>card_data</code> is provided and invalid, or missing required fields like <code>name</code>), 500, 503 (potentially during cold start).</li> </ul>"},{"location":"developer_guide/registry/#delete-card_id","title":"<code>DELETE /{card_id}</code>","text":"<ul> <li>Summary: Deactivate an Agent Card (Soft Delete).</li> <li>Description: Marks an Agent Card as inactive (<code>is_active = false</code>). This is a soft delete; the record remains but is typically excluded from public listings via the <code>active_only=true</code> default filter. Only the owner can deactivate.</li> <li>Authentication: Required (<code>X-Api-Key</code>, must match card owner).</li> <li>Path Parameter:<ul> <li><code>card_id</code> (UUID): The ID of the agent card to deactivate.</li> </ul> </li> <li>Success Response: <code>204 No Content</code> (Empty body).</li> <li>Errors: 401, 403 (if not owner), 404, 500, 503 (potentially during cold start).</li> </ul>"},{"location":"developer_guide/registry/#utilities-utils","title":"Utilities (<code>/utils</code>)","text":""},{"location":"developer_guide/registry/#post-validate-card","title":"<code>POST /validate-card</code>","text":"<ul> <li>Summary: Validate Agent Card Data.</li> <li>Description: Validates provided JSON data against the official <code>agentvault.models.AgentCard</code> schema without registering or storing it. Useful for developers checking their <code>agent-card.json</code> before submission.</li> <li>Authentication: Public.</li> <li>Request Body: <code>schemas.AgentCardValidationRequest</code> <pre><code>{\n  \"card_data\": {\n    \"schemaVersion\": \"1.0\",\n    \"name\": \"Agent to Validate\",\n    \"humanReadableId\": \"org/test-valid\",\n    \"agentVersion\": \"1.0\",\n    \"description\": \"...\",\n    \"url\": \"http://valid.url\",\n    \"provider\": {\"name\": \"Test\"},\n    \"capabilities\": {\"a2aVersion\": \"1.0\"},\n    \"authSchemes\": [{\"scheme\": \"none\"}]\n    // ... other card fields ...\n  }\n}\n</code></pre></li> <li>Success Response (200 OK): <code>schemas.AgentCardValidationResponse</code><ul> <li>If Valid: <pre><code>{\n  \"is_valid\": true,\n  \"detail\": null,\n  \"validated_card_data\": { /* ... validated/normalized card data ... */ }\n}\n</code></pre></li> <li>If Invalid: <pre><code>{\n  \"is_valid\": false,\n  \"detail\": \"Validation Error: Field required [type=missing, loc=('url',), ...]\",\n  \"validated_card_data\": null\n}\n</code></pre></li> </ul> </li> <li>Errors: 422 (if the request body itself is invalid, e.g., missing <code>card_data</code>), 500, 503 (potentially during cold start).</li> </ul>"},{"location":"developer_guide/server_sdk/","title":"Developer Guide: Server SDK (<code>agentvault-server-sdk</code>)","text":"<p>The <code>agentvault-server-sdk</code> provides tools and abstractions to simplify the development of A2A-compliant agent servers in Python, particularly when using the FastAPI web framework. It helps you focus on your agent's core logic while the SDK handles much of the A2A protocol boilerplate.</p>"},{"location":"developer_guide/server_sdk/#installation","title":"Installation","text":"<p>Install the SDK from PyPI:</p> <p><pre><code>pip install agentvault-server-sdk\n</code></pre> (Note: This automatically installs the <code>agentvault</code> client library as a dependency).</p> <p>See the main Installation Guide for more details, including setting up a development environment to run from source.</p>"},{"location":"developer_guide/server_sdk/#core-concepts","title":"Core Concepts","text":"<p>The SDK revolves around implementing an agent logic class (inheriting from <code>BaseA2AAgent</code>) and integrating it with a web framework (currently FastAPI).</p>"},{"location":"developer_guide/server_sdk/#1-basea2aagent-agentpy","title":"1. <code>BaseA2AAgent</code> (<code>agent.py</code>)","text":"<p>This is the abstract base class your agent logic should inherit from.</p> <ul> <li>Purpose: Defines the standard interface the A2A protocol expects an agent server to fulfill.</li> <li>Required Methods: If you are not using the <code>@a2a_method</code> decorator for all standard methods, you must implement these <code>async</code> methods in your subclass:<ul> <li><code>handle_task_send(task_id: Optional[str], message: Message) -&gt; str</code>: Processes incoming messages (<code>tasks/send</code> JSON-RPC method). Should handle task creation or updates and return the task ID.</li> <li><code>handle_task_get(task_id: str) -&gt; Task</code>: Retrieves the full state (<code>Task</code> model) of a specific task (<code>tasks/get</code> JSON-RPC method).</li> <li><code>handle_task_cancel(task_id: str) -&gt; bool</code>: Attempts to cancel a task (<code>tasks/cancel</code> JSON-RPC method), returning <code>True</code> if the request is accepted.</li> <li><code>handle_subscribe_request(task_id: str) -&gt; AsyncGenerator[A2AEvent, None]</code>: Returns an async generator yielding <code>A2AEvent</code> objects for SSE streaming (<code>tasks/sendSubscribe</code> JSON-RPC method). The SDK router consumes this generator.</li> </ul> </li> <li>Alternative (<code>@a2a_method</code>): For agents handling only specific or custom methods, or if you prefer a decorator-based approach, you can use the <code>@a2a_method</code> decorator on individual methods instead of implementing all <code>handle_...</code> methods (see below).</li> </ul>"},{"location":"developer_guide/server_sdk/#2-task-state-management-statepy","title":"2. Task State Management (<code>state.py</code>)","text":"<p>Handling asynchronous tasks requires managing their state (Submitted, Working, Completed, etc.) and potentially associated data (messages, artifacts). The SDK provides tools for this.</p> <ul> <li><code>TaskContext</code>: A basic dataclass holding <code>task_id</code>, <code>current_state</code>, <code>created_at</code>, <code>updated_at</code>. You can subclass this to store agent-specific task data.     <pre><code># Example of extending TaskContext\nfrom dataclasses import dataclass, field\nfrom typing import List\nfrom agentvault.models import Message, Artifact\nfrom agentvault_server_sdk.state import TaskContext\n\n@dataclass\nclass MyAgentTaskContext(TaskContext):\n    conversation_history: List[Message] = field(default_factory=list)\n    generated_artifacts: List[Artifact] = field(default_factory=list)\n    # Add other fields your agent needs to track per task\n</code></pre></li> <li><code>BaseTaskStore</code>: An abstract base class defining the interface for storing, retrieving, updating, and deleting <code>TaskContext</code> objects (e.g., <code>create_task</code>, <code>get_task</code>, <code>update_task_state</code>, <code>delete_task</code>). It also defines the interface for managing SSE event listeners (<code>add_listener</code>, <code>remove_listener</code>) and notifying them (<code>notify_status_update</code>, <code>notify_message_event</code>, <code>notify_artifact_event</code>).</li> <li><code>InMemoryTaskStore</code>: A simple, non-persistent dictionary-based implementation of <code>BaseTaskStore</code>. Suitable only for development or single-instance agents where task state loss on restart is acceptable. Production agents typically require implementing a custom <code>BaseTaskStore</code> backed by a persistent database (SQL, NoSQL) or a distributed cache (Redis).</li> <li>Notification Helpers: When using a <code>BaseTaskStore</code> implementation (like <code>InMemoryTaskStore</code> or your own), your agent logic (e.g., background processing tasks) should call methods like <code>task_store.notify_status_update(...)</code>, <code>task_store.notify_message_event(...)</code>, <code>task_store.notify_artifact_event(...)</code> whenever a relevant event occurs (e.g., state change, message generation, artifact creation). The <code>create_a2a_router</code> integration uses these notifications to automatically format and send the correct SSE events to subscribed clients via the <code>handle_subscribe_request</code> stream.</li> </ul>"},{"location":"developer_guide/server_sdk/#3-fastapi-integration-fastapi_integrationpy","title":"3. FastAPI Integration (<code>fastapi_integration.py</code>)","text":"<p>The <code>create_a2a_router</code> function bridges your agent logic (either a <code>BaseA2AAgent</code> subclass or a class using <code>@a2a_method</code>) with the FastAPI web framework.</p> <ul> <li>Purpose: Creates a FastAPI <code>APIRouter</code> that automatically exposes the standard A2A JSON-RPC methods (<code>tasks/send</code>, <code>tasks/get</code>, <code>tasks/cancel</code>, <code>tasks/sendSubscribe</code>) and routes them to your agent implementation's corresponding <code>handle_...</code> methods or decorated methods. It also handles JSON-RPC request parsing, basic validation, and SSE stream setup.</li> <li>Authentication: Note that authentication (e.g., checking <code>X-Api-Key</code> or <code>Authorization</code> headers) is typically handled before the request reaches the A2A router, usually via FastAPI Dependencies applied to the router or the main app. The SDK router itself does not perform authentication checks.</li> <li> <p>Usage: The following steps outline how to integrate the router into your FastAPI application:</p> <ol> <li> <p>Instantiate Agent and Task Store: <pre><code>from fastapi import FastAPI\nfrom agentvault_server_sdk import BaseA2AAgent\nfrom agentvault_server_sdk.state import InMemoryTaskStore # Or your custom store\n# Import your agent class\nfrom my_agent_logic import MyAgent\n\ntask_store = InMemoryTaskStore()\nmy_agent_instance = MyAgent(task_store_ref=task_store) # Pass store if needed\n</code></pre></p> </li> <li> <p>Create the A2A Router: Pass the agent instance and the task store to the factory function.     <pre><code>from agentvault_server_sdk import create_a2a_router\n\na2a_router = create_a2a_router(\n    agent=my_agent_instance,\n    task_store=task_store # Required for SSE notifications\n)\n</code></pre></p> </li> <li> <p>Create FastAPI App and Include Router: Mount the router at your desired prefix (typically <code>/a2a</code>).     <pre><code>app = FastAPI(title=\"My A2A Agent\")\napp.include_router(a2a_router, prefix=\"/a2a\") # Mount at standard /a2a path\n</code></pre></p> </li> <li> <p>Add Exception Handlers (CRITICAL): You must add the SDK's exception handlers to your main FastAPI <code>app</code> instance. These handlers translate internal Python exceptions raised by your agent or the SDK (like <code>TaskNotFoundError</code>, <code>ValueError</code>, <code>AgentServerError</code>) into correctly formatted JSON-RPC error responses that clients expect. Without these, clients will receive generic HTTP 500 errors instead of specific, actionable JSON-RPC errors.     <pre><code>from fastapi import Request\nfrom fastapi.responses import JSONResponse\nfrom pydantic import ValidationError as PydanticValidationError\n# from pydantic_core import ValidationError as PydanticValidationError # If using Pydantic v2\nfrom agentvault_server_sdk.exceptions import AgentServerError, TaskNotFoundError\nfrom agentvault_server_sdk.fastapi_integration import (\n    task_not_found_handler, validation_exception_handler,\n    agent_server_error_handler, generic_exception_handler\n)\n\n# Assuming 'app' is your FastAPI instance from step 3\napp.add_exception_handler(TaskNotFoundError, task_not_found_handler)\napp.add_exception_handler(ValueError, validation_exception_handler)\napp.add_exception_handler(TypeError, validation_exception_handler)\napp.add_exception_handler(PydanticValidationError, validation_exception_handler)\napp.add_exception_handler(AgentServerError, agent_server_error_handler)\napp.add_exception_handler(Exception, generic_exception_handler) # Catch-all\n</code></pre></p> </li> </ol> </li> </ul>"},{"location":"developer_guide/server_sdk/#4-a2a-method-decorator-a2a_method","title":"4. A2A Method Decorator (<code>@a2a_method</code>)","text":"<p>An alternative or supplement to implementing the full <code>BaseA2AAgent</code> interface.</p> <ul> <li>Purpose: Expose individual <code>async def</code> methods within your agent class as specific JSON-RPC methods. Useful for simpler agents, custom methods beyond the standard A2A set, or overriding specific standard methods with custom logic.</li> <li>Usage: <pre><code>from agentvault_server_sdk import BaseA2AAgent, a2a_method\nfrom agentvault.models import Task # Example import\n\nclass DecoratedAgent(BaseA2AAgent): # Still inherit for structure\n\n    @a2a_method(\"custom/ping\")\n    async def ping_handler(self) -&gt; str:\n        # No parameters needed\n        return \"pong\"\n\n    @a2a_method(\"tasks/get\") # Override standard method\n    async def custom_get_task(self, task_id: str) -&gt; Task: # Params validated from type hints\n        # ... custom logic to fetch task ...\n        task_data = await get_my_task_data(task_id)\n        # Return value validated against type hint\n        return Task(**task_data)\n\n    # If using only decorators for standard methods, you don't *need*\n    # to implement the corresponding handle_ methods. The router will\n    # prioritize decorated methods and return \"Method not found\" for others.\n</code></pre></li> <li>Validation: The <code>create_a2a_router</code> automatically validates incoming JSON-RPC <code>params</code> against the decorated function's type hints (using Pydantic internally). If validation fails (e.g., client sends wrong type for <code>task_id</code>), a <code>ValueError</code> or <code>PydanticValidationError</code> will likely be raised, which should be caught by the <code>validation_exception_handler</code> registered on the FastAPI app, returning a JSON-RPC <code>Invalid Params</code> error. The return value is also validated against the function's return type hint.</li> </ul>"},{"location":"developer_guide/server_sdk/#5-packaging-tool-agentvault-sdk-package-packagerclipy","title":"5. Packaging Tool (<code>agentvault-sdk package</code>) (<code>packager/cli.py</code>)","text":"<p>A CLI tool to help prepare your agent project for deployment, typically via Docker.</p> <ul> <li>Command: <code>agentvault-sdk package [OPTIONS]</code></li> <li>Functionality: Generates a standard multi-stage <code>Dockerfile</code>, a <code>.dockerignore</code> file, and copies <code>requirements.txt</code> and optionally <code>agent-card.json</code> to a specified output directory, ready for <code>docker build</code>.</li> <li>Key Options:<ul> <li><code>--output-dir DIRECTORY</code> / <code>-o DIRECTORY</code>: (Required) Directory to write Dockerfile and other artifacts.</li> <li><code>--entrypoint TEXT</code>: (Required) Python import path to the FastAPI app instance (e.g., <code>my_agent.main:app</code>).</li> <li><code>--python TEXT</code>: Python version for the base image tag (e.g., 3.10, 3.11). [default: 3.11]</li> <li><code>--suffix TEXT</code>: Suffix for the python base image (e.g., slim-bookworm, alpine). [default: slim-bookworm]</li> <li><code>--port INTEGER</code>: Port the application will listen on inside the container. [default: 8000]</li> <li><code>--requirements PATH</code> / <code>-r PATH</code>: Path to the requirements.txt file. If not provided, it looks for <code>./requirements.txt</code> in the current directory and copies it if found. Issues a warning if the SDK dependency seems missing.</li> <li><code>--agent-card PATH</code> / <code>-c PATH</code>: Path to the agent-card.json file. If provided, it will be copied into the output directory.</li> <li><code>--app-dir TEXT</code>: Directory inside the container where the application code will reside. [default: /app]</li> </ul> </li> <li>Example: <pre><code># Assuming FastAPI app is in src/my_agent/main.py as 'app'\n# and requirements.txt / agent-card.json are in the current directory\nagentvault-sdk package \\\n    --output-dir ./build \\\n    --entrypoint my_agent.main:app \\\n    --requirements ./requirements.txt \\\n    --agent-card ./agent-card.json \\\n    --python 3.11\n\n# Then build the image from the project root:\n# docker build -t my-agent-image:latest -f ./build/Dockerfile .\n</code></pre></li> </ul>"},{"location":"developer_guide/server_sdk/#building-a-basic-agent-conceptual-steps","title":"Building a Basic Agent (Conceptual Steps)","text":"<ol> <li>Define Agent Logic: Create a class inheriting from <code>BaseA2AAgent</code> (or use decorators).</li> <li>Implement Handlers/Methods: Implement the required <code>async handle_...</code> methods (or decorate specific methods) to handle A2A requests.</li> <li>Manage State: Choose or implement a <code>BaseTaskStore</code> (start with <code>InMemoryTaskStore</code> for development). Pass it to your agent instance. Crucially, call <code>task_store.notify_...</code> methods from your agent's background processing logic (e.g., the code handling the actual work initiated by <code>handle_task_send</code>) to send SSE updates to subscribed clients.</li> <li>Create FastAPI App: Set up a standard FastAPI application (<code>main.py</code>).</li> <li>Instantiate Agent &amp; Store: Create instances of your agent class and task store.</li> <li>Create &amp; Include Router: Use <code>create_a2a_router(agent=..., task_store=...)</code> and include the returned router in your FastAPI app (e.g., at prefix <code>/a2a</code>).</li> <li>Add Exception Handlers: Add the required SDK exception handlers (<code>task_not_found_handler</code>, etc.) to your main FastAPI app instance using <code>app.add_exception_handler(...)</code>.</li> <li>Create Agent Card: Write an <code>agent-card.json</code> describing your agent, ensuring the <code>url</code> points to your FastAPI A2A endpoint (e.g., <code>http://your-host/a2a</code>). Include appropriate <code>authSchemes</code>.</li> <li>Run: Use <code>uvicorn main:app --host ... --port ...</code>.</li> <li>(Optional) Package: Use <code>agentvault-sdk package</code> to generate Docker artifacts for deployment.</li> </ol> <p>Refer to the Basic A2A Server Example for a complete, runnable implementation.</p>"},{"location":"developer_guide/testing/","title":"Developer Guide: Testing Utilities (<code>agentvault-testing-utils</code>)","text":"<p>The <code>agentvault-testing-utils</code> package is an internal development tool providing shared mocks, pytest fixtures, data factories, and helper functions. Its purpose is to streamline and standardize testing across the different AgentVault components (<code>agentvault_library</code>, <code>agentvault_cli</code>, <code>agentvault_registry</code>, <code>agentvault_server_sdk</code>).</p> <p>Note: This package is not intended for end-users or for distribution on PyPI. It's used within the AgentVault monorepo's development workflow.</p>"},{"location":"developer_guide/testing/#installation","title":"Installation","text":"<p>This package is installed as a development dependency when setting up the main project environment using Poetry:</p> <pre><code># From the monorepo root (AgentVault/)\npoetry install --with dev\n</code></pre>"},{"location":"developer_guide/testing/#provided-utilities","title":"Provided Utilities","text":""},{"location":"developer_guide/testing/#1-mocks-mockspy","title":"1. Mocks (<code>mocks.py</code>)","text":"<ul> <li><code>MockAgentVaultClient</code>:<ul> <li>Purpose: A mock implementation of <code>agentvault.client.AgentVaultClient</code>. Use this in tests for components that use the client library (like the CLI or potentially other agents) to simulate A2A interactions without making real network calls.</li> <li>Features:<ul> <li>Configurable return values for async methods (e.g., <code>mock_client.initiate_task_return_value = \"task-abc\"</code>).</li> <li>Configurable side effects (exceptions) for async methods (e.g., <code>mock_client.get_task_status_side_effect = A2AConnectionError(\"Mock connection failed\")</code>).</li> <li>Call recording via the <code>mock_client.call_recorder</code> attribute (an <code>unittest.mock.AsyncMock</code> instance). Use standard <code>assert_awaited_once_with</code>, <code>assert_has_calls</code>, etc. on this recorder.</li> <li>Supports async context management (<code>async with mock_client:</code>).</li> </ul> </li> <li>Example: <pre><code>import pytest\nfrom unittest.mock import call, ANY # Import ANY for flexible matching\nfrom agentvault_testing_utils.mocks import MockAgentVaultClient\nfrom agentvault.models import Task, TaskState # Assuming Task model exists\nfrom agentvault.exceptions import A2AConnectionError\n\n@pytest.mark.asyncio\nasync def test_cli_run_logic(mocker): # Assuming pytest-mock 'mocker' fixture\n    # --- Setup ---\n    mock_client = MockAgentVaultClient()\n    # Patch the location where AgentVaultClient is instantiated in the code under test\n    mocker.patch('agentvault_cli.commands.run.AgentVaultClient', return_value=mock_client)\n\n    # Configure mock behavior\n    mock_client.initiate_task_return_value = \"task-from-mock\"\n    # Create a mock Task object or use a real one if needed\n    mock_task_result = MagicMock(spec=Task)\n    mock_task_result.state = TaskState.COMPLETED\n    mock_client.get_task_status_return_value = mock_task_result\n\n    # --- Action ---\n    # Execute the function or command that uses the AgentVaultClient\n    # e.g., await run_cli_command_logic(...)\n\n    # --- Assertions ---\n    # Check initiate_task was called correctly\n    mock_client.call_recorder.initiate_task.assert_awaited_once_with(\n        agent_card=ANY, initial_message=ANY, key_manager=ANY,\n        mcp_context=None, webhook_url=None # Check default args if needed\n    )\n    # Check get_task_status was called with the ID returned by initiate_task\n    mock_client.call_recorder.get_task_status.assert_awaited_with(\n         agent_card=ANY, task_id=\"task-from-mock\", key_manager=ANY\n    )\n</code></pre></li> </ul> </li> </ul>"},{"location":"developer_guide/testing/#2-mock-server-fixtures-mock_serverpy-fixturespy","title":"2. Mock Server &amp; Fixtures (<code>mock_server.py</code>, <code>fixtures.py</code>)","text":"<ul> <li> <p><code>mock_a2a_server</code> (Pytest Fixture):</p> <ul> <li>Purpose: Provides a more realistic testing environment by mocking the HTTP endpoints of an A2A agent server (<code>/a2a</code>) and its associated OAuth token endpoint (<code>/token</code>) using <code>respx</code>. Useful for testing the <code>AgentVaultClient</code> itself or components that make real HTTP requests to agents.</li> <li>Features:<ul> <li>Sets up <code>respx</code> routes for <code>POST /a2a</code> and <code>POST /token</code> at a test URL.</li> <li>Handles basic JSON-RPC routing for standard A2A methods (<code>tasks/send</code>, <code>get</code>, <code>cancel</code>, <code>sendSubscribe</code>).</li> <li>Simulates basic task state via an in-memory <code>task_store</code> dictionary accessible from the fixture. You can pre-populate this store in your test.</li> <li>Simulates SSE streaming for <code>tasks/sendSubscribe</code> based on an <code>sse_event_store</code> list accessible from the fixture. You pre-populate this list with the <code>A2AEvent</code> objects you want the mock server to stream back.</li> <li>Provides the <code>base_url</code> of the mock server.</li> </ul> </li> <li>Return Type: <code>MockServerInfo</code> (NamedTuple) with fields:<ul> <li><code>base_url</code> (str): The base URL of the mock server (e.g., <code>https://mock-a2a-agent.test</code>).</li> <li><code>task_store</code> (Dict[str, Dict]): Dictionary mapping task IDs to their simple state dict (e.g., <code>{'state': TaskState.WORKING}</code>).</li> <li><code>sse_event_store</code> (Dict[str, List[A2AEvent]]): Dictionary mapping task IDs to a list of <code>A2AEvent</code> objects to be yielded by the mock SSE stream.</li> </ul> </li> <li>Example: <pre><code>import pytest\nimport httpx\nfrom agentvault_testing_utils.fixtures import mock_a2a_server, MockServerInfo\n# Import necessary models\nfrom agentvault.models import TaskState, TaskStatusUpdateEvent, Message, TextPart\nfrom agentvault.client import AgentVaultClient # Import the real client\nimport datetime\n\n@pytest.mark.asyncio\nasync def test_client_get_status_against_mock_server(mock_a2a_server: MockServerInfo, mocker):\n    # --- Setup Mock Server State ---\n    task_id = \"live-test-task-get\"\n    # Pre-populate the task store the mock server will use\n    mock_a2a_server.task_store[task_id] = {\"state\": TaskState.WORKING}\n\n    # --- Action ---\n    # Use the real AgentVaultClient against the mock server's URL\n    mock_card = mocker.MagicMock() # Mock the card\n    mock_card.url = f\"{mock_a2a_server.base_url}/a2a\"\n    mock_card.auth_schemes = [] # Assume no auth for simplicity\n\n    async with AgentVaultClient() as client:\n         # This call will hit the respx route set up by the fixture\n         task_details = await client.get_task_status(\n             agent_card=mock_card,\n             task_id=task_id,\n             key_manager=mocker.MagicMock() # Mock key manager\n         )\n\n    # --- Assertions ---\n    assert task_details.id == task_id\n    assert task_details.state == TaskState.WORKING # Check state returned by mock\n</code></pre></li> </ul> </li> <li> <p><code>setup_mock_a2a_routes</code>: The underlying function used by the <code>mock_a2a_server</code> fixture to configure <code>respx</code> routes. Can be used directly for more complex or custom mock server setups outside the fixture.</p> </li> <li>JSON-RPC Helpers: <code>create_jsonrpc_success_response</code>, <code>create_jsonrpc_error_response</code> for constructing standard JSON-RPC response dictionaries in custom mock handlers.</li> </ul>"},{"location":"developer_guide/testing/#3-factories-factoriespy","title":"3. Factories (<code>factories.py</code>)","text":"<ul> <li><code>create_test_agent_card(**overrides)</code>:<ul> <li>Purpose: Generates <code>agentvault.models.AgentCard</code> Pydantic model instances with sensible default values. Simplifies creating valid test data for agent cards.</li> <li>Features: Accepts keyword arguments to override any top-level or nested field in the default card structure (uses deep merging for nested dicts). Performs validation using the actual <code>AgentCard</code> model.</li> <li>Example: <pre><code>from agentvault_testing_utils.factories import create_test_agent_card\n\n# Create a card with default values\ndefault_card = create_test_agent_card()\n\n# Create a card overriding name and adding an OAuth scheme\ncustom_card = create_test_agent_card(\n    name=\"My Custom OAuth Agent\",\n    authSchemes=[ # Overwrites the default 'none' scheme\n        {\"scheme\": \"oauth2\", \"tokenUrl\": \"https://my-agent.test/token\"}\n    ],\n    tags=[\"custom\", \"oauth\"] # Overwrites default tags\n)\n</code></pre></li> </ul> </li> </ul>"},{"location":"developer_guide/testing/#4-test-agents-agentspy","title":"4. Test Agents (<code>agents.py</code>)","text":"<ul> <li><code>EchoAgent</code>:<ul> <li>Purpose: A minimal, functional implementation of <code>agentvault_server_sdk.BaseA2AAgent</code>. It uses an <code>InMemoryTaskStore</code> to manage state, echoes the first message content back via SSE notification, and transitions through basic states (Submitted -&gt; Working -&gt; Completed).</li> <li>Use Case: Ideal for testing the Server SDK's <code>create_a2a_router</code>, basic A2A client interactions, and SSE streaming logic without needing a complex real agent implementation. Useful for end-to-end tests of the client library or CLI against a basic functional agent.</li> <li>Example (Testing SDK Router): See the Server SDK Developer Guide or the Basic A2A Server Example.</li> </ul> </li> </ul>"},{"location":"developer_guide/testing/#5-assertion-helpers-assertionspy","title":"5. Assertion Helpers (<code>assertions.py</code>)","text":"<ul> <li>Purpose: Provide convenient functions for asserting that specific A2A JSON-RPC calls were made, simplifying tests that interact with <code>MockAgentVaultClient</code> or <code>respx</code>.</li> <li>Key Functions:<ul> <li><code>assert_a2a_call(mock_calls, method, params_contain=None, req_id=None)</code>: Checks if any call in the provided list (<code>httpx.Request</code> list from <code>respx.calls</code> or <code>MagicMock.call_args_list</code> from <code>MockAgentVaultClient.call_recorder</code>) matches the specified JSON-RPC <code>method</code>, optional <code>req_id</code>, and optionally contains the key-value pairs in <code>params_contain</code> within its <code>params</code> object (performs a subset check).</li> <li><code>assert_a2a_sequence(mock_calls, expected_sequence)</code>: Checks if the sequence of parseable A2A calls matches the <code>expected_sequence</code> (a list of <code>(method, params_contain)</code> tuples). Ignores non-JSON-RPC calls in the list.</li> <li>Example: <pre><code>from agentvault_testing_utils.assertions import assert_a2a_call, assert_a2a_sequence\nfrom unittest.mock import call # For sequence assertion with MagicMock\n\n# --- Using MockAgentVaultClient ---\n# await mock_client.initiate_task(...)\n# await mock_client.get_task_status(task_id=\"task-123\", ...)\n\n# Assert a specific call was made (anywhere in the list)\nassert_a2a_call(\n    mock_client.call_recorder.call_args_list, # Pass the call list\n    method=\"tasks/get\",\n    params_contain={\"id\": \"task-123\"}\n)\n\n# Assert the exact sequence of calls\nexpected_seq = [\n    (\"initiate_task\", None), # Use the Python method name for MagicMock recorder\n    (\"get_task_status\", {\"task_id\": \"task-123\"}) # Use Python param names\n]\n# Note: assert_a2a_sequence expects JSON-RPC method names in the sequence definition\n# Adjust if using MagicMock recorder directly vs parsing httpx requests.\n# Example below assumes parsing logic handles method name mapping if needed.\nexpected_rpc_seq = [\n     (\"tasks/send\", None), # Assuming initiate_task maps to tasks/send\n     (\"tasks/get\", {\"id\": \"task-123\"})\n]\n# assert_a2a_sequence(mock_client.call_recorder.call_args_list, expected_rpc_seq)\n\n\n# --- Using respx ---\n# with respx.mock:\n#     # setup routes...\n#     # await http_client.post(url, json=payload1)\n#     # await http_client.post(url, json=payload2)\n\n# Assert a specific call was made\nassert_a2a_call(\n    respx.calls, # Pass the list of httpx.Request objects\n    method=\"tasks/send\",\n    params_contain={\"message\": {\"role\": \"user\"}}\n)\n\n# Assert the sequence\nexpected_respx_seq = [\n    (\"tasks/send\", {\"id\": None}),\n    (\"tasks/get\", {\"id\": \"task-abc\"})\n]\nassert_a2a_sequence(respx.calls, expected_respx_seq)\n</code></pre></li> </ul> </li> </ul>"},{"location":"examples/basic_a2a_server/","title":"AgentVault Server SDK - Basic A2A Server Example","text":"<p>This example demonstrates the minimal setup required to create an A2A-compliant agent server using the <code>agentvault-server-sdk</code> and FastAPI.</p>"},{"location":"examples/basic_a2a_server/#components","title":"Components","text":"<ul> <li><code>requirements.txt</code>: Defines Python dependencies (<code>fastapi</code>, <code>uvicorn</code>, <code>agentvault-server-sdk</code>).</li> <li><code>main.py</code>:<ul> <li>Defines a simple <code>MySimpleAgent</code> class inheriting from <code>BaseA2AAgent</code>.</li> <li>Implements basic logic for the required A2A methods (<code>handle_task_send</code>, <code>handle_task_get</code>, <code>handle_task_cancel</code>, <code>handle_subscribe_request</code>).</li> <li>Uses the SDK's <code>create_a2a_router</code> to automatically generate the <code>/a2a</code> JSON-RPC endpoint.</li> <li>Includes necessary FastAPI exception handlers required by the router.</li> <li>Sets up a FastAPI application.</li> <li>Serves the agent's <code>agent-card.json</code> at <code>/agent-card.json</code>.</li> <li>Includes a <code>uvicorn</code> runner block.</li> </ul> </li> <li><code>agent-card.json</code>: A minimal, valid Agent Card describing this example agent.</li> </ul>"},{"location":"examples/basic_a2a_server/#setup","title":"Setup","text":"<ol> <li>Navigate: Open your terminal in this directory (<code>examples/basic_a2a_server</code>).</li> <li>Install Dependencies: Create and activate a virtual environment, then install the requirements. This will install the local SDK package.     <pre><code># Create venv (optional, recommended)\n# python -m venv .venv\n# source .venv/bin/activate  # On Linux/macOS\n# .venv\\Scripts\\activate    # On Windows\n\npip install -r requirements.txt\n</code></pre> Note: This assumes the <code>agentvault-server-sdk</code> and <code>agentvault_library</code> directories are located correctly relative to this example as specified in <code>requirements.txt</code>. Adjust the <code>-e ../../...</code> paths if your structure differs.</li> </ol>"},{"location":"examples/basic_a2a_server/#running-the-server","title":"Running the Server","text":"<p>Start the FastAPI server using Uvicorn:</p> <pre><code>uvicorn main:app --reload --port 8000\n</code></pre> <ul> <li><code>--reload</code>: Enables auto-reloading when code changes (useful for development).</li> <li><code>--port 8000</code>: Specifies the port to run on (matches the default <code>url</code> in <code>agent-card.json</code>).</li> </ul> <p>You should see Uvicorn startup messages indicating the server is running on <code>http://127.0.0.1:8000</code>.</p>"},{"location":"examples/basic_a2a_server/#testing-with-agentvault-cli","title":"Testing with AgentVault CLI","text":"<p>Once the server is running, you can interact with it using the <code>agentvault-cli</code>:</p> <ol> <li> <p>Check Agent Card: Open <code>http://localhost:8000/agent-card.json</code> in your browser or use <code>curl</code> to verify the card is served correctly.</p> </li> <li> <p>Run a Task: Use the <code>agentvault run</code> command, pointing the <code>--agent</code> flag to the card URL.     <pre><code>agentvault run --agent http://localhost:8000/agent-card.json --input \"Hello SDK Agent!\"\n</code></pre></p> </li> </ol> <p>You should see output similar to this:</p> <pre><code>SUCCESS: Successfully loaded agent: SDK Basic Echo Agent (examples/simple-agent)\nINFO: Agent A2A Endpoint: http://localhost:8000/a2a\nINFO: Initiating task with agent...\nSUCCESS: Task initiated successfully. Task ID: simple-xxxxxxxx\nINFO: Waiting for events... (Press Ctrl+C to request cancellation)\nINFO: Task Status: WORKING\n\u250c Message from Assistant \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Echo: Hello SDK Agent!                                                    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\nINFO: Task Status: COMPLETED\nINFO: Task reached terminal state.\nINFO: --------------------\nINFO: Final Task State: COMPLETED\nSUCCESS: Task completed.\n</code></pre> <p>This confirms the CLI can load the card, initiate a task via the SDK-generated router, stream the status updates and the echo message, and recognize task completion.</p>"},{"location":"examples/langchain_integration/","title":"AgentVault LangChain Integration Example","text":"<p>This directory contains a basic example demonstrating how to integrate an AgentVault A2A compliant agent as a tool within the LangChain framework.</p>"},{"location":"examples/langchain_integration/#components","title":"Components","text":"<ul> <li><code>requirements.txt</code>: Defines the necessary Python dependencies (<code>langchain-core</code>, <code>agentvault</code>, <code>httpx</code>).</li> <li><code>a2a_tool.py</code>: Contains the <code>A2AAgentTool</code> class, which inherits from LangChain's <code>BaseTool</code>. This tool handles the interaction with a remote A2A agent using the <code>agentvault</code> client library.</li> <li><code>example_usage.py</code>: A simple script showing how to instantiate and invoke the <code>A2AAgentTool</code>.</li> </ul>"},{"location":"examples/langchain_integration/#setup","title":"Setup","text":"<ol> <li> <p>Install Dependencies: Navigate to this directory (<code>examples/langchain_integration</code>) in your terminal and install the requirements. This includes installing the local <code>agentvault</code> library in editable mode.     <pre><code>pip install -r requirements.txt\n</code></pre> Note: This assumes your virtual environment is activated and you are in the correct directory. The <code>-e ../../agentvault_library</code> line installs the library from your local source tree.</p> </li> <li> <p>Configure Agent Reference: Open <code>example_usage.py</code> and modify the <code>EXAMPLE_AGENT_REF</code> variable to point to a valid agent:</p> <ul> <li>Agent ID: If using an ID from a running AgentVault Registry (e.g., <code>test-org/my-agent</code>), ensure the <code>AGENTVAULT_REGISTRY_URL</code> environment variable is set correctly or modify the default in <code>a2a_tool.py</code>.</li> <li>Agent URL: Provide the direct URL to the agent's <code>agent-card.json</code> (e.g., <code>http://localhost:8001/agent-card.json</code>).</li> <li>Local File: Provide the path to a local <code>agent-card.json</code> file (e.g., <code>./path/to/your/agent-card.json</code>).</li> </ul> </li> <li> <p>Configure Credentials: If the target agent requires authentication (e.g., <code>apiKey</code> or <code>oauth2</code>), ensure the necessary credentials are set up using the AgentVault CLI (<code>agentvault config set ...</code>) or environment variables, matching the <code>service_identifier</code> specified in the agent's card.</p> </li> </ol>"},{"location":"examples/langchain_integration/#running-the-example","title":"Running the Example","text":"<p>Once set up, you can run the example script:</p> <pre><code>python example_usage.py\n</code></pre> <p>The script will:</p> <ol> <li>Instantiate the <code>A2AAgentTool</code>.</li> <li>Prepare the input (agent reference and text prompt).</li> <li>Invoke the tool's <code>_arun</code> method.</li> <li>The tool will internally use <code>AgentVaultClient</code> to:<ul> <li>Load the agent card.</li> <li>Initiate a task.</li> <li>Stream events (though only assistant text messages are captured in this basic example).</li> <li>Wait for the task to complete.</li> </ul> </li> <li>Print the final aggregated text response from the agent.</li> </ol> <p>Note: This example primarily demonstrates the tool's structure and integration. For it to fully succeed, you need a running A2A agent accessible at the specified <code>EXAMPLE_AGENT_REF</code> that can handle the input prompt. You can use the <code>agentvault-server-sdk</code> examples or your own agent implementation.</p>"},{"location":"examples/library_usage_example/","title":"AgentVault Library Usage Example","text":"<p>This example demonstrates how to use the core <code>agentvault</code> Python client library directly to interact with an A2A-compliant agent, without using the <code>agentvault_cli</code>.</p>"},{"location":"examples/library_usage_example/#concept","title":"Concept","text":"<p>The <code>agentvault</code> library provides the <code>AgentVaultClient</code> class, which handles the complexities of the A2A protocol (JSON-RPC, SSE, authentication via <code>KeyManager</code>). This script shows the basic workflow:</p> <ol> <li>Load the target agent's <code>AgentCard</code>.</li> <li>Instantiate <code>KeyManager</code> to handle potential authentication credentials.</li> <li>Instantiate <code>AgentVaultClient</code> (using <code>async with</code>).</li> <li>Call <code>client.initiate_task</code> to start the interaction.</li> <li>Use <code>async for event in client.receive_messages(...)</code> to stream and process events (status updates, messages, artifacts) from the agent.</li> <li>Handle potential exceptions.</li> </ol>"},{"location":"examples/library_usage_example/#components","title":"Components","text":"<ul> <li><code>requirements.txt</code>: Lists the <code>agentvault</code> library dependency.</li> <li><code>main.py</code>: The Python script demonstrating the library usage. It takes the agent reference and input text as command-line arguments.</li> </ul>"},{"location":"examples/library_usage_example/#setup","title":"Setup","text":"<ol> <li>Navigate: Open your terminal in this directory (<code>examples/library_usage_example</code>).</li> <li>Install Dependencies: Create and activate a virtual environment, then install the requirements.     <pre><code># Create venv (optional, recommended)\n# python -m venv .venv\n# source .venv/bin/activate  # On Linux/macOS\n# .venv\\Scripts\\activate    # On Windows\n\npip install -r requirements.txt\n</code></pre> Note: This installs the <code>agentvault</code> library from your local source tree.</li> <li>Target Agent: By default, the script targets the Basic A2A Server example agent card URL (<code>http://localhost:8000/agent-card.json</code>). Ensure that agent is running if you use the default. You can target other agents using the <code>--agent-ref</code> argument.</li> <li>Credentials (If Needed): If the target agent requires authentication (e.g., <code>apiKey</code> or <code>oauth2</code>), ensure the necessary credentials are configured using the AgentVault CLI (<code>agentvault config set ...</code>) or environment variables, matching the <code>service_identifier</code> specified in the agent's card. The <code>KeyManager</code> within the script will automatically pick them up.</li> </ol>"},{"location":"examples/library_usage_example/#running-the-example","title":"Running the Example","text":"<p>Execute the Python script from your terminal, providing the input text:</p> <pre><code># Run against the default Basic Echo Agent (make sure it's running on port 8000)\npython main.py --input \"Hello from the library!\"\n\n# Run against a different agent (e.g., one requiring auth)\n# Ensure 'my-api-key-service' is configured via `agentvault config` if needed\n# python main.py --agent-ref \"https://some-other-agent.com/card.json\" --input \"Process this data\" --key-service \"my-api-key-service\"\n</code></pre> <p>Expected Output:</p> <p>The script will print logs indicating the steps it's taking (loading card, initiating task) and then print details for each event received from the agent via the SSE stream (status changes, messages, artifacts).</p> <pre><code>INFO:root:Loading agent card: http://localhost:8000/agent-card.json\nINFO:root:Loaded Agent: SDK Basic Echo Agent\nINFO:root:Initiating task...\nINFO:agentvault.client:Initiating task with agent: examples/simple-agent\nINFO:agentvault.client:Task successfully initiated with agent examples/simple-agent. Task ID: simple-xxxxxx\nINFO:root:Task initiated: simple-xxxxxx\nINFO:root:Streaming events...\nINFO:agentvault.client:Subscribing to events for task simple-xxxxxx on agent: examples/simple-agent\nINFO:root:  Status Update: WORKING (Msg: N/A)\nINFO:root:  Message Received (Role: assistant):\nINFO:root:    Text: Echo response for task simple-xxxxxx\nINFO:root:  Status Update: COMPLETED (Msg: N/A)\nINFO:root:  Terminal state reached.\nINFO:root:\n--- Final Aggregated Agent Response ---\nEcho response for task simple-xxxxxx\n---------------------------------------\n</code></pre>"},{"location":"examples/oauth_agent_example/","title":"AgentVault Server SDK - OAuth2 Agent Example","text":"<p>This example demonstrates how to build an A2A agent that requires OAuth2 Client Credentials authentication using the <code>agentvault-server-sdk</code> and FastAPI.</p>"},{"location":"examples/oauth_agent_example/#components","title":"Components","text":"<ul> <li><code>.env.example</code>: Example environment variables for setting the mock Client ID and Secret the server will accept.</li> <li><code>agent-card.json</code>: Describes the agent, specifying the <code>oauth2</code> auth scheme and the <code>/token</code> endpoint URL.</li> <li><code>requirements.txt</code>: Python dependencies (<code>fastapi</code>, <code>uvicorn</code>, <code>agentvault-server-sdk</code>, <code>python-dotenv</code>).</li> <li><code>src/oauth_agent_example/agent.py</code>: Defines the simple <code>OAuthProtectedAgent</code> logic.</li> <li><code>src/oauth_agent_example/main.py</code>:<ul> <li>Sets up the FastAPI application.</li> <li>Includes the SDK's A2A router at <code>/a2a</code>.</li> <li>Adds a custom <code>POST /token</code> endpoint to handle the OAuth2 Client Credentials grant flow, validating against environment variables.</li> <li>Adds a FastAPI dependency (<code>verify_token</code>) using <code>HTTPBearer</code> to protect the <code>/a2a</code> router, ensuring requests have a valid mock Bearer token obtained from <code>/token</code>.</li> <li>Includes the required SDK exception handlers.</li> </ul> </li> </ul>"},{"location":"examples/oauth_agent_example/#setup","title":"Setup","text":"<ol> <li>Navigate: Open your terminal in this directory (<code>examples/oauth_agent_example</code>).</li> <li>Install Dependencies: Create and activate a virtual environment, then install the requirements.     <pre><code># Create venv (optional, recommended)\n# python -m venv .venv\n# source .venv/bin/activate  # On Linux/macOS\n# .venv\\Scripts\\activate    # On Windows\n\npip install -r requirements.txt\n</code></pre> Note: This installs the SDK and core library from your local source tree.</li> <li>Configure Server Credentials:<ul> <li>Copy <code>.env.example</code> to <code>.env</code>.</li> <li>Review the <code>MOCK_CLIENT_ID</code> and <code>MOCK_CLIENT_SECRET</code> in <code>.env</code>. These are the credentials the server will expect the client to provide to the <code>/token</code> endpoint. You can change them if desired.</li> </ul> </li> </ol>"},{"location":"examples/oauth_agent_example/#running-the-server","title":"Running the Server","text":"<p>Start the FastAPI server using Uvicorn. It will load the credentials from the <code>.env</code> file.</p> <p><pre><code>uvicorn src.oauth_agent_example.main:app --reload --port 8002\n</code></pre> *   <code>--reload</code>: Enables auto-reloading for development. *   <code>--port 8002</code>: Specifies the port (matches <code>agent-card.json</code>).</p> <p>The server should start, hosting the <code>/a2a</code> endpoint and the <code>/token</code> endpoint.</p>"},{"location":"examples/oauth_agent_example/#configuring-client-credentials","title":"Configuring Client Credentials","text":"<p>Before you can interact with this agent using <code>agentvault_cli</code>, you need to configure the client-side credentials that match the ones the server expects.</p> <ol> <li>Open a NEW terminal window/tab (keep the server running).</li> <li>Activate the AgentVault virtual environment if you haven't already (<code>source .venv/bin/activate</code> or similar).</li> <li> <p>Use <code>agentvault config set</code>: Use the <code>service_identifier</code> from <code>agent-card.json</code> (<code>example-oauth-agent</code>) and the <code>--oauth-configure</code> flag. Enter the same Client ID and Secret that are defined in the server's <code>.env</code> file when prompted.</p> <pre><code>agentvault config set example-oauth-agent --oauth-configure\n# --&gt; Enter OAuth Client ID for 'example-oauth-agent': test-client-id-123\n# --&gt; Enter OAuth Client Secret for 'example-oauth-agent': ************************\n# --&gt; Confirm OAuth Client Secret for 'example-oauth-agent': ************************\n# SUCCESS: OAuth credentials for 'example-oauth-agent' stored successfully in keyring.\n</code></pre> </li> </ol>"},{"location":"examples/oauth_agent_example/#testing-with-agentvault-cli","title":"Testing with AgentVault CLI","text":"<p>Now that the server is running and client credentials are configured, you can test the interaction:</p> <pre><code>agentvault run --agent http://localhost:8002/agent-card.json --input \"Test OAuth Auth\"\n</code></pre> <p>Expected Behavior:</p> <ol> <li>The <code>agentvault</code> client library (used by the CLI) will load the agent card.</li> <li>It sees the <code>oauth2</code> scheme and the <code>tokenUrl</code>.</li> <li>It uses the <code>KeyManager</code> to retrieve the Client ID/Secret you configured for <code>example-oauth-agent</code>.</li> <li>It makes a <code>POST</code> request to <code>http://localhost:8002/token</code> with the credentials.</li> <li>The server's <code>/token</code> endpoint validates the credentials against the <code>.env</code> file and returns a mock access token.</li> <li>The client library receives the token.</li> <li>It makes the <code>POST</code> request to <code>http://localhost:8002/a2a</code> for the <code>tasks/send</code> method, including the <code>Authorization: Bearer &lt;mock_access_token&gt;</code> header.</li> <li>The server's <code>verify_token</code> dependency validates the token.</li> <li>The SDK router calls the agent's <code>handle_task_send</code> method.</li> <li>The agent starts the task and sends back SSE events confirming authentication worked.</li> </ol> <p>You should see output similar to the Basic Echo example, but the underlying process involves the OAuth token exchange. If authentication fails (e.g., wrong client credentials configured), the <code>run</code> command will report an authentication error.</p>"},{"location":"examples/stateful_agent_example/","title":"AgentVault Server SDK - Stateful Agent Example","text":"<p>This example demonstrates how to build an A2A agent that maintains state across multiple interactions within a single task lifecycle using the <code>agentvault-server-sdk</code>.</p>"},{"location":"examples/stateful_agent_example/#concept","title":"Concept","text":"<p>Many agent tasks aren't single-shot requests but involve a conversation or a process that evolves over time. This requires the agent to:</p> <ol> <li>Store Task-Specific State: Remember information relevant to the ongoing task (e.g., conversation history, intermediate results, user preferences).</li> <li>Update State: Modify the stored state based on new messages or internal processing.</li> <li>Handle Multiple Interactions: Accept subsequent <code>tasks/send</code> requests for the same task ID and use the stored state to continue processing.</li> </ol> <p>This example implements a simple chat agent that stores the message history in memory for each task.</p>"},{"location":"examples/stateful_agent_example/#components","title":"Components","text":"<ul> <li><code>agent-card.json</code>: Describes the agent.</li> <li><code>requirements.txt</code>: Python dependencies (<code>fastapi</code>, <code>uvicorn</code>, <code>agentvault-server-sdk</code>).</li> <li><code>src/stateful_agent_example/state.py</code>: Defines <code>ChatTaskContext</code> which inherits from the SDK's <code>TaskContext</code> and adds a <code>history</code> list to store messages.</li> <li><code>src/stateful_agent_example/agent.py</code>: Defines the <code>StatefulChatAgent</code> logic:<ul> <li>Uses <code>InMemoryTaskStore</code> to store <code>ChatTaskContext</code> instances.</li> <li><code>handle_task_send</code>: Creates a new task context on the first call, storing the initial message. For subsequent calls with the same task ID, it appends the new message to the existing context's history and signals a background processing loop using an <code>asyncio.Event</code>.</li> <li><code>_process_task</code>: A background <code>asyncio</code> task started for each new chat task. It waits for new messages (signaled via the <code>asyncio.Event</code>) and generates simple responses based on the message count.</li> <li>Other handlers (<code>get</code>, <code>cancel</code>, <code>subscribe</code>) interact with the task store.</li> </ul> </li> <li><code>src/stateful_agent_example/main.py</code>: Sets up the FastAPI application, includes the SDK's A2A router, and required exception handlers.</li> </ul>"},{"location":"examples/stateful_agent_example/#setup","title":"Setup","text":"<ol> <li>Navigate: Open your terminal in this directory (<code>examples/stateful_agent_example</code>).</li> <li>Install Dependencies: Create and activate a virtual environment, then install the requirements.     <pre><code># Create venv (optional, recommended)\n# python -m venv .venv\n# source .venv/bin/activate  # On Linux/macOS\n# .venv\\Scripts\\activate    # On Windows\n\npip install -r requirements.txt\n</code></pre> Note: This installs the SDK and core library from your local source tree.</li> </ol>"},{"location":"examples/stateful_agent_example/#running-the-server","title":"Running the Server","text":"<p>Start the FastAPI server using Uvicorn:</p> <p><pre><code>uvicorn src.stateful_agent_example.main:app --reload --port 8003\n</code></pre> *   <code>--reload</code>: Enables auto-reloading for development. *   <code>--port 8003</code>: Specifies the port (matches <code>agent-card.json</code>).</p> <p>The server should start, hosting the <code>/a2a</code> endpoint.</p>"},{"location":"examples/stateful_agent_example/#testing-with-agentvault-cli","title":"Testing with AgentVault CLI","text":"<p>You can test the stateful interaction using the <code>agentvault_cli</code>:</p> <ol> <li> <p>Initiate Task: Send the first message. Note the <code>Task ID</code> returned.     <pre><code>agentvault run --agent http://localhost:8003/agent-card.json --input \"Hello stateful agent!\"\n# --&gt; SUCCESS: Task initiated successfully. Task ID: stateful-task-xxxxxx\n# --&gt; INFO: Waiting for events...\n# --&gt; INFO: Task Status: WORKING\n# --&gt; Message from Assistant: Received message 1. History length is now 1.\n# --&gt; INFO: Task Status: WORKING # (Agent waits for more input)\n# (Press Ctrl+C here or leave it running)\n</code></pre> Note: The agent stays in the <code>WORKING</code> state, waiting for more input or cancellation.</p> </li> <li> <p>Send Subsequent Message: Open a new terminal (or stop the previous <code>run</code> command with Ctrl+C if desired) and use the same Task ID obtained in step 1 to send another message.     <pre><code># Replace stateful-task-xxxxxx with the actual ID from step 1\nagentvault run --agent http://localhost:8003/agent-card.json --input \"This is the second message.\" --task-id stateful-task-xxxxxx\n# --&gt; SUCCESS: Task message sent successfully to task stateful-task-xxxxxx\n# --&gt; INFO: Waiting for events...\n# --&gt; Message from Assistant: Received message 2. History length is now 2.\n# --&gt; INFO: Task Status: WORKING\n# (Press Ctrl+C or leave running)\n</code></pre>     The running agent (or its background task) should detect the new message and send another response via SSE.</p> </li> <li> <p>(Optional) Cancel Task: You can cancel the task using its ID.     <pre><code># Replace stateful-task-xxxxxx with the actual ID\nagentvault run --agent http://localhost:8003/agent-card.json --cancel --task-id stateful-task-xxxxxx\n# --&gt; SUCCESS: Task cancellation request sent successfully for task stateful-task-xxxxxx\n# --&gt; INFO: Waiting for events...\n# --&gt; INFO: Task Status: CANCELED\n</code></pre></p> </li> </ol> <p>This demonstrates how the agent uses the <code>task_id</code> to access and update the correct state (<code>ChatTaskContext</code>) stored by the <code>InMemoryTaskStore</code> across multiple <code>run</code> command invocations. In a real application, you would likely use a persistent store instead of <code>InMemoryTaskStore</code>.</p>"},{"location":"user_guide/cli/","title":"User Guide: AgentVault CLI (<code>agentvault_cli</code>)","text":"<p>The <code>agentvault_cli</code> is your command-line tool for interacting with the AgentVault ecosystem. It allows you to manage credentials for accessing agents, discover agents registered in the central registry, and execute tasks on remote A2A-compliant agents.</p>"},{"location":"user_guide/cli/#installation","title":"Installation","text":"<p>Please refer to the main Installation Guide for instructions on installing the CLI using <code>pip</code>.</p>"},{"location":"user_guide/cli/#core-commands","title":"Core Commands","text":"<p>The CLI is structured around several main commands. Get an overview by running:</p> <pre><code>agentvault_cli --help\n</code></pre>"},{"location":"user_guide/cli/#config","title":"<code>config</code>","text":"<p>Manage local API keys and OAuth credentials required to authenticate with different agents or services. Credentials can be stored securely in the OS keyring or referenced via environment variables or files.</p> <p>Usage:</p> <pre><code>agentvault_cli config --help\n</code></pre> <p>This command group helps you configure how the <code>agentvault_cli run</code> command (and underlying library) finds the necessary secrets to talk to different agents.</p> <p>Key Subcommands:</p> <ul> <li> <p><code>set &lt;service_id&gt; [OPTIONS]</code>:</p> <ul> <li>Purpose: Configure how credentials for a specific service (identified by <code>&lt;service_id&gt;</code>) are sourced or stored. The <code>&lt;service_id&gt;</code> is a name you choose locally (e.g., <code>openai</code>, <code>my-custom-agent-key</code>, <code>google-oauth-agent</code>) that the <code>KeyManager</code> uses to find the right secret. It often corresponds to the <code>service_identifier</code> in an Agent Card's <code>authSchemes</code>, but can be different.</li> <li>Options:<ul> <li><code>--env</code>: Guidance Only. Prints instructions on how to set environment variables (<code>AGENTVAULT_KEY_&lt;SERVICE_ID_UPPER&gt;</code>, <code>AGENTVAULT_OAUTH_&lt;SERVICE_ID_UPPER&gt;_CLIENT_ID</code>, <code>AGENTVAULT_OAUTH_&lt;SERVICE_ID_UPPER&gt;_CLIENT_SECRET</code>). It does not store anything itself.</li> <li><code>--file &lt;path&gt;</code>: Guidance Only. Prints instructions on how to format a <code>.env</code> or <code>.json</code> file to store credentials that the <code>KeyManager</code> could potentially load (if configured during library initialization, which the CLI doesn't do by default).</li> <li><code>--keyring</code>: Stores API Key. Securely prompts for an API key and stores it in your operating system's default keyring, associated with the <code>&lt;service_id&gt;</code>. This is the recommended secure method for storing API keys via the CLI.</li> <li><code>--oauth-configure</code>: Stores OAuth Credentials. Securely prompts for an OAuth 2.0 Client ID and Client Secret and stores them in the OS keyring, associated with the <code>&lt;service_id&gt;</code>. Required for agents using the <code>oauth2</code> authentication scheme.</li> </ul> </li> </ul> <p>Example (Store OpenAI API Key securely): <pre><code># Use 'openai' as the local service_id\nagentvault_cli config set openai --keyring\n# --&gt; Enter API key: ************\n# --&gt; Confirm API key: ************\n# SUCCESS: API key for 'openai' stored successfully in keyring.\n</code></pre> Example (Configure OAuth for a Google agent): <pre><code># Use 'google-agent-oauth' as the local service_id\nagentvault_cli config set google-agent-oauth --oauth-configure\n# --&gt; Enter OAuth Client ID for 'google-agent-oauth': &lt;paste_client_id&gt;\n# --&gt; Enter OAuth Client Secret for 'google-agent-oauth': ************\n# --&gt; Confirm OAuth Client Secret for 'google-agent-oauth': ************\n# SUCCESS: OAuth credentials for 'google-agent-oauth' stored successfully in keyring.\n</code></pre> Example (Guidance for Environment Variables): <pre><code>agentvault_cli config set anthropic --env\n# --&gt; Guidance: To use environment variables for 'anthropic':\n# --&gt;   For API Key: Set AGENTVAULT_KEY_ANTHROPIC=&lt;your_api_key&gt;\n# --&gt;   ... (OAuth guidance also shown) ...\n</code></pre></p> </li> <li> <p><code>get &lt;service_id&gt; [OPTIONS]</code>:</p> <ul> <li>Purpose: Checks how credentials for a given <code>&lt;service_id&gt;</code> are currently being sourced by the <code>KeyManager</code> (Environment, File, Keyring). It checks the cache first, then attempts to load from the keyring if enabled.</li> <li>Options:<ul> <li><code>--show-key</code>: Displays the first few characters of the found API key (use with caution).</li> <li><code>--show-oauth-id</code>: Displays the configured OAuth Client ID if found. Example: <pre><code>agentvault_cli config get openai\n# --&gt; Credential status for service 'openai':\n# --&gt;   API Key: Found (Source: KEYRING)\n# --&gt;     (Use --show-key to display a masked version)\n# --&gt;   OAuth Credentials: Not Configured\n\nagentvault_cli config get google-agent-oauth --show-oauth-id\n# --&gt; Credential status for service 'google-agent-oauth':\n# --&gt;   API Key: Not Found\n# --&gt;   OAuth Credentials: Configured (Source: KEYRING)\n# --&gt;     Client ID: 12345-abcde.apps.googleusercontent.com\n</code></pre></li> </ul> </li> </ul> </li> <li> <p><code>list</code>:</p> <ul> <li>Purpose: Shows a summary of services for which credentials have been detected during initialization from environment variables or specified key files (if the underlying library was configured with a key file path, which the default CLI is not).</li> <li>Note: This command does not actively scan the OS keyring. Keys stored only in the keyring will typically not appear in this list unless they were accessed previously by a <code>get</code> command in the same CLI invocation.</li> </ul> </li> </ul>"},{"location":"user_guide/cli/#discover","title":"<code>discover</code>","text":"<p>Search for agents registered in the central AgentVault Registry.</p> <p>Usage:</p> <pre><code>agentvault_cli discover --help\nagentvault_cli discover [SEARCH_QUERY] [OPTIONS]\n</code></pre> <ul> <li><code>[SEARCH_QUERY]</code> (Optional): Text to search for (case-insensitive) in agent names or descriptions.</li> <li><code>--registry &lt;url&gt;</code>: Specify the URL of the AgentVault Registry API.<ul> <li>Defaults to the value of the <code>AGENTVAULT_REGISTRY_URL</code> environment variable if set.</li> <li>If the environment variable is not set, it defaults to the public registry: <code>https://agentvault-registry-api.onrender.com</code>.</li> <li>(Note: The public registry runs on a free tier and may take up to 60 seconds to wake up on the first request.)</li> </ul> </li> <li><code>--limit &lt;n&gt;</code>: Maximum results per page (default: 25, max: 250).</li> <li><code>--offset &lt;n&gt;</code>: Number of results to skip (for pagination, default: 0).</li> <li><code>--tags &lt;tag&gt;</code> (Repeatable): Filter by tags. Only agents possessing all specified tags will be returned (e.g., <code>--tags weather --tags forecast</code>).</li> <li><code>--has-tee [true|false]</code> (Optional): Filter agents based on whether they declare TEE support in their Agent Card.</li> <li><code>--tee-type &lt;type&gt;</code> (Optional): Filter agents by the specific TEE type declared (e.g., <code>AWS Nitro Enclaves</code>, <code>Intel SGX</code>).</li> </ul> <p>Example: <pre><code># List first 10 agents containing \"weather\" from the public registry\nagentvault_cli discover weather --limit 10\n\n# List agents tagged with \"nlp\" from a local registry\nagentvault_cli discover --tags nlp --registry http://localhost:8000\n\n# Find agents declaring TEE support on the public registry\nagentvault_cli discover --has-tee true\n</code></pre></p> <p>The output is displayed in a table format.</p>"},{"location":"user_guide/cli/#run","title":"<code>run</code>","text":"<p>Execute a task on a specific remote agent using the A2A protocol.</p> <p>Usage:</p> <pre><code>agentvault_cli run --help\nagentvault_cli run --agent &lt;agent_ref&gt; --input &lt;input_data&gt; [OPTIONS]\n</code></pre> <ul> <li><code>--agent &lt;agent_ref&gt;</code> / <code>-a &lt;agent_ref&gt;</code> (Required): Identifies the target agent. This is crucial. It can be:<ul> <li>An Agent ID from the registry (e.g., <code>examples/simple-agent</code>, <code>my-org/my-agent</code>). The CLI will use the <code>--registry</code> URL to fetch the corresponding Agent Card.</li> <li>A direct URL to the agent's <code>agent-card.json</code> (e.g., <code>http://localhost:8001/agent-card.json</code>).</li> <li>A local file path to the agent's <code>agent-card.json</code> (e.g., <code>../examples/basic_a2a_server/agent-card.json</code>).</li> </ul> </li> <li><code>--input &lt;input_data&gt;</code> / <code>-i &lt;input_data&gt;</code> (Required): The input text for the agent's task.<ul> <li>To read input from a file, prefix the path with <code>@</code>. Example: <code>--input @./prompts/my_request.txt</code>.</li> </ul> </li> <li><code>--context-file &lt;path&gt;</code>: Path to a local JSON file containing MCP context data to send with the initial message.</li> <li><code>--registry &lt;url&gt;</code>: Registry URL (only used if <code>&lt;agent_ref&gt;</code> is an Agent ID). Defaults to <code>AGENTVAULT_REGISTRY_URL</code> env var or the public registry <code>https://agentvault-registry-api.onrender.com</code>. (Note the cold start delay for the public instance).</li> <li><code>--key-service &lt;service_id&gt;</code>: Important for Authentication. If the agent requires authentication (e.g., <code>apiKey</code> or <code>oauth2</code>) and its Agent Card doesn't specify a <code>service_identifier</code>, or if you want to use credentials stored under a different local name, use this flag to tell the <code>KeyManager</code> which local service ID to use for lookup. Example: <code>--key-service openai</code>.</li> <li><code>--auth-key &lt;key&gt;</code>: INSECURE - FOR TESTING ONLY. Directly provide the API key on the command line. This bypasses the <code>KeyManager</code> lookup for agents using the <code>apiKey</code> scheme. Avoid using this for sensitive keys.</li> <li><code>--output-artifacts &lt;directory&gt;</code>: If provided, artifact content larger than 1KB received via SSE will be saved to files in this directory (named using artifact ID and inferred extension) instead of being printed (truncated) to the console.</li> </ul> <p>Example (Running the basic SDK example agent locally): <pre><code># Assumes the basic_a2a_server example is running on port 8000\nagentvault_cli run --agent http://localhost:8000/agent-card.json --input \"Hello Agent!\"\n</code></pre></p> <p>Example (Running an agent from the public registry requiring an OpenAI key): <pre><code># First, ensure the key is configured:\n# agentvault config set openai --keyring (and enter key)\n\n# Then run the task (assuming agent 'some-org/openai-agent' uses 'openai' service ID)\n# The --registry flag is omitted, so it uses the default public registry\nagentvault_cli run --agent some-org/openai-agent --input \"Summarize the concept of AI agents.\"\n\n# Or, if the agent card didn't specify 'openai' as service_identifier:\nagentvault_cli run --agent some-org/openai-agent --input \"Summarize...\" --key-service openai\n</code></pre></p> <p>The <code>run</code> command connects to the agent and streams Server-Sent Events (SSE) back to your terminal, showing status updates, messages from the agent/tools, and artifact information using <code>rich</code> formatting for better readability.</p>"},{"location":"user_guide/cli/#usage-tips","title":"Usage Tips","text":"<p>(Same as before - Shell History, fzf + awk)</p>"},{"location":"user_guide/cli/#re-running-run-commands","title":"Re-running <code>run</code> Commands","text":"<p>The <code>agentvault_cli run</code> command can sometimes involve long agent identifiers or input strings. To easily recall and reuse previous commands:</p> <ul> <li>Shell History Search (Ctrl+R): Most shells allow you to search your command history interactively. Press <code>Ctrl+R</code> and start typing parts of the command you want to find (e.g., <code>run</code>, the agent ID, part of the input).</li> <li><code>history</code> Command: Use <code>history | grep agentvault_cli run</code> (or similar filter) to list previous run commands. You can then execute a specific command number (e.g., <code>!123</code>).</li> <li><code>fzf</code> (Fuzzy Finder): If you have <code>fzf</code> installed, you can pipe your history to it for interactive fuzzy searching: <code>history | fzf</code>. Select the desired command and press Enter to execute it. This is very powerful for quickly finding complex commands.</li> </ul>"},{"location":"user_guide/cli/#interactive-agent-selection-discover-fzf","title":"Interactive Agent Selection (<code>discover</code> + <code>fzf</code>)","text":"<p>If you have command-line tools like <code>fzf</code> (fuzzy finder) and <code>awk</code> installed, you can create powerful interactive workflows. For example, to discover agents, select one interactively, and then immediately run a task on it:</p> <pre><code># Example: Discover agents matching \"weather\", select one, run with input\n# Assumes default public registry or AGENTVAULT_REGISTRY_URL is set\nagentvault_cli discover weather | fzf --height 40% --border --header \"Select Agent:\" | awk '{print $1}' | xargs -I {} agentvault_cli run --agent {} --input \"What is the forecast for London?\"\n</code></pre> <p>Explanation:</p> <ol> <li><code>agentvault_cli discover weather</code>: Lists agents matching \"weather\" from the configured registry.</li> <li><code>| fzf ...</code>: Pipes the list to <code>fzf</code> for interactive selection.</li> <li><code>| awk '{print $1}'</code>: Extracts the first column (the Agent ID) from the line selected in <code>fzf</code>. Note: You might need to adjust <code>$1</code> if the ID is in a different column based on your terminal width or <code>discover</code> output format.</li> <li><code>| xargs -I {} ...</code>: Takes the extracted ID (<code>{}</code>) and inserts it into the <code>agentvault_cli run</code> command.</li> </ol> <p>This allows you to quickly find and use agents without manually copying and pasting IDs.</p>"}]}